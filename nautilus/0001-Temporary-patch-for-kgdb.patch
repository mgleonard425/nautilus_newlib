From a121f1c42d31414260b236afb723c93b86966bef Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Mon, 7 Aug 2017 10:49:55 -0500
Subject: [PATCH] Temporary patch for kgdb

---
 Kconfig                     |   27 +
 include/dev/serial.h        |    3 +
 include/nautilus/gdb-stub.h |   31 ++
 src/arch/x64/init.c         |   10 +
 src/dev/Kconfig             |   21 +
 src/dev/ps2.c               |   21 +
 src/dev/serial.c            |  221 +++++++-
 src/nautilus/Makefile       |    2 +
 src/nautilus/gdb-stub.c     | 1197 +++++++++++++++++++++++++++++++++++++++++++
 src/nautilus/scheduler.c    |   29 ++
 src/nautilus/smp.c          |   12 +
 11 files changed, 1550 insertions(+), 24 deletions(-)
 create mode 100644 include/nautilus/gdb-stub.h
 create mode 100644 src/nautilus/gdb-stub.c

diff --git a/Kconfig b/Kconfig
index 4f5b1f1..d4c6e78 100644
--- a/Kconfig
+++ b/Kconfig
@@ -577,6 +577,33 @@ menu Debugging
       make sure that a thread hasn't overrun its allocated 
       stack
 
+   config ENABLE_REMOTE_DEBUGGING
+    depends on !HVM_HRT
+    bool "Enable Remote Debugging"
+    default n
+    help
+      This allows remote debugging, currently using GDB.  It integrates
+      a GDB stub that talks (currently) via a serial port using
+      polled operation.   You must also enable the relevant port
+      in the serial configuration under the device section.  
+      Note that the kernel will halt at startup until the 
+      debugger attaches.  
+
+    config ATTACH_REMOTE_DEBUGGER_AT_BOOT
+     depends on ENABLE_REMOTE_DEBUGGING
+     bool "Attach the remote debugger at boot"
+     default n
+     help
+       Attach the remote debugger as part of the initialization
+       process at boot, before other CPUs are up
+
+    config DEBUG_REMOTE_DEBUGGER
+     depends on ENABLE_REMOTE_DEBUGGING
+     bool "Debug Remote Debugger"
+     default n
+     help
+        Turn on debug prints for the remote debugger subsystem
+
     config DEBUG_PAGING
       bool "Debug Paging"
       depends on DEBUG_PRINTS
diff --git a/include/dev/serial.h b/include/dev/serial.h
index e6ae268..09d2dae 100644
--- a/include/dev/serial.h
+++ b/include/dev/serial.h
@@ -40,6 +40,9 @@ void serial_printlevel(int level, const char * format, ...);
 
 void serial_print_poll(const char *format, ...);
 
+int serial_debugger_put(uint8_t c);
+int serial_debugger_get(uint8_t *c);
+
 void  serial_early_init(void);
 
 void  serial_init(void);
diff --git a/include/nautilus/gdb-stub.h b/include/nautilus/gdb-stub.h
new file mode 100644
index 0000000..072ffb9
--- /dev/null
+++ b/include/nautilus/gdb-stub.h
@@ -0,0 +1,31 @@
+/* 
+ * This file is part of the Nautilus AeroKernel developed
+ * by the Hobbes and V3VEE Projects with funding from the 
+ * United States National  Science Foundation and the Department of Energy.  
+ *
+ * The V3VEE Project is a joint project between Northwestern University
+ * and the University of New Mexico.  The Hobbes Project is a collaboration
+ * led by Sandia National Laboratories that includes several national 
+ * laboratories and universities. You can find out more at:
+ * http://www.v3vee.org  and
+ * http://xstack.sandia.gov/hobbes
+ *
+ * Copyright (c) 2017, Peter Dinda <pdinda@northwestern.edu>
+ * Copyright (c) 2017, The V3VEE Project  <http://www.v3vee.org> 
+ *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
+ * All rights reserved.
+ *
+ * Author:  Peter Dinda <pdinda@northwestern.edu>
+ *
+ * This is free software.  You are permitted to use,
+ * redistribute, and modify it as specified in the file "LICENSE.txt".
+ */
+#ifndef _GDB_STUB
+#define _GDB_STUB
+
+int nk_gdb_init();
+int nk_gdb_init_ap();
+
+#define nk_gdb_breakpoint_here() __asm__ __volatile__ ("int $3")
+
+#endif
diff --git a/src/arch/x64/init.c b/src/arch/x64/init.c
index 7af85aa..5e207f9 100644
--- a/src/arch/x64/init.c
+++ b/src/arch/x64/init.c
@@ -55,6 +55,11 @@
 #include <nautilus/loader.h>
 #include <nautilus/shell.h>
 
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING 
+#include <nautilus/gdb-stub.h>
+#endif
+
+
 #include <dev/apic.h>
 #include <dev/pci.h>
 #include <dev/hpet.h>
@@ -274,6 +279,11 @@ init (unsigned long mbd,
     // Bring serial device up early so we can have output
     serial_early_init();
 
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING 
+    nk_gdb_init();
+#endif
+
+
     nk_dev_init();
     nk_char_dev_init();
     nk_block_dev_init();
diff --git a/src/dev/Kconfig b/src/dev/Kconfig
index fe6f9d5..e46b919 100644
--- a/src/dev/Kconfig
+++ b/src/dev/Kconfig
@@ -1,5 +1,7 @@
 menu "Device options"
 
+menu "Serial Options"
+
 config SERIAL_REDIRECT
     bool "Serial Redirect"
     depends on !HVM_HRT
@@ -19,7 +21,26 @@ config SERIAL_REDIRECT_PORT
     default "1"
     help
       Specifies which serial port to use for serial redirection. E.g. 1 is COM1.
+      This must be different from your debug port!
+
+config SERIAL_DEBUGGER
+    bool "Serial Debugger"
+    depends on ENABLE_REMOTE_DEBUGGING
+    default n
+    help
+        Provide a simple serial interface to a remote debugger
+
+config SERIAL_DEBUGGER_PORT
+    depends on SERIAL_DEBUGGER
+    int "Serial COM Port for remote debugger interface"
+    range 1 4
+    default "2"
+    help
+      Specifies which serial port to use for serial connection to 
+      a remote debugger (e.g. gdb).   1 is COM1, etc.  This must
+      be different from your redirect port!
       
+endmenu      
 
 config APIC_FORCE_XAPIC_MODE
     bool "Force APIC to use XAPIC mode"
diff --git a/src/dev/ps2.c b/src/dev/ps2.c
index 5669c95..b10b2a7 100644
--- a/src/dev/ps2.c
+++ b/src/dev/ps2.c
@@ -31,6 +31,9 @@
 #include <dev/ps2.h>
 #include <nautilus/vc.h>
 #include <nautilus/dev.h>
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING
+#include <nautilus/gdb-stub.h>
+#endif
 
 #ifndef NAUT_CONFIG_DEBUG_PS2
 #undef DEBUG_PRINT
@@ -475,11 +478,29 @@ kbd_handler (excp_entry_t * excp, excp_vec_t vec, void *state)
       nk_thread_exit(ret);
     }
 #endif
+
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING
+    if (scan == 0x42) {
+      // F8 down - stop
+      nk_gdb_breakpoint_here();
+      // now ignore the key
+      goto out;
+    }
+    if (scan == 0xc2) {
+      // F8 up - ignore the key
+      goto out;
+    }
+#endif
+    
     
     switcher(scan);
+
+    goto out; // to avoid label warning
     
   }
 
+ out:
+
   IRQ_HANDLER_END();
   return 0;
 }
diff --git a/src/dev/serial.c b/src/dev/serial.c
index e345e9b..7f62f46 100644
--- a/src/dev/serial.c
+++ b/src/dev/serial.c
@@ -33,6 +33,9 @@
 #include <nautilus/dev.h>
 #include <nautilus/chardev.h>
 #include <dev/serial.h>
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING
+#include <nautilus/gdb-stub.h>
+#endif
 
 /*
   The serial driver provides two stages of functionality
@@ -52,6 +55,12 @@
 
   We expect that every serial port is at least a 16550. 
   We run all serial ports at 115200 N81. 
+
+  The serial driver additionally supports a single optional remote debugging
+  port.  This port is handled in polling fashion with the exception that
+  any receive interrupt or line status (e.g., break) interrupt is interpretted
+  as being an interrupt request from the debugger,and will trigger an immediate
+  breakpoint. 
   
 */
 
@@ -74,6 +83,17 @@ static uint8_t com_irq;
 static struct serial_state *early_dev = 0;
 
 
+#ifdef NAUT_CONFIG_SERIAL_DEBUGGER
+/* 
+  This state supports polled operation for communication with
+  a remote debugger
+*/
+static uint16_t   debug_io_addr = 0;
+
+#endif
+
+
+
 /* The following state is for late output */
 
 #define BUFSIZE 512
@@ -544,6 +564,61 @@ serial_irq_handler_early (excp_entry_t * excp,
   return 0;
 }
 
+
+#ifdef NAUT_CONFIG_SERIAL_DEBUGGER
+static int 
+debug_irq_handler(excp_entry_t * excp,
+		  excp_vec_t vec,
+		  void *state)
+{
+  char iir;
+  char id;
+  char lsr;
+
+  INFO_PRINT("Debugger interrupt\n");
+
+  iir = inb(debug_io_addr + IIR);
+  
+  id = iir & 0xf;
+  
+  // we care only about receive and LSR->break
+  
+  switch (id) {
+  case 4:
+    INFO_PRINT("Debugger Received Data\n");
+    // receive data - gdb handler will absorb the data
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING
+    nk_gdb_breakpoint_here();
+#endif    
+    break;
+    
+  case 6:
+    // LSR
+    lsr = inb(debug_io_addr + LSR);
+    
+    if (lsr & 0x10) {
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING
+      INFO_PRINT("Debugger LSR break\n");
+      // BREAK
+      nk_gdb_breakpoint_here();
+#endif
+    }
+    // we don't care about any other condition
+    
+    break;
+    
+  default:
+    // we don't care
+    break;
+  }
+  
+  IRQ_HANDLER_END();
+  
+  return 0;
+}
+
+#endif
+
 static int serial_irq_handler_late(struct serial_state *s,excp_entry_t * excp,excp_vec_t vec, void *state)
 {
     uint8_t iir;
@@ -622,9 +697,15 @@ serial_irq_handler(excp_entry_t * excp,
 }
 
 static void 
-serial_init_addr (uint16_t io_addr) 
+serial_init_addr (uint16_t io_addr, int debugger) 
 {
-  serial_io_addr = io_addr;
+  if (!debugger) {
+    serial_io_addr = io_addr;
+  } else {
+#ifdef NAUT_CONFIG_SERIAL_DEBUGGER
+    debug_io_addr = io_addr;
+#endif
+  }
 
   //  io_adr = 3F8=COM1, 2F8=COM2, 3E8=COM3, 2E8=COM4 
 
@@ -643,23 +724,34 @@ serial_init_addr (uint16_t io_addr)
   // 8 bit word, 1 stop bit, no parity
   outb(0x03, io_addr + 3);
 
-  // interrupt enable register
-  // raise interrupts on received data available
-  // do not raise interrupts on transmit holding register empty,
-  // line status update, or modem status update
-  // 
-  outb(0x01, io_addr + 1);
-
-  // FIFO control register
-  // turn off FIFOs;  chip is now going to raise an
-  // interrupt on every incoming word
-  outb(0, io_addr + 2);
-  
-  // prepare to handle our ~~~ commands
-  reset_cmd_fsm();
-  
-  // enable interrupts (bit 3)
-  // outb(0x08, io_addr + 4);
+  if (!debugger) { 
+      // interrupt enable register
+      // raise interrupts on received data available
+      // do not raise interrupts on transmit holding register empty,
+      // line status update, or modem status update
+      // 
+      outb(0x01, io_addr + 1);
+      
+      // FIFO control register
+      // turn off FIFOs;  chip is now going to raise an
+      // interrupt on every incoming word
+      outb(0, io_addr + 2);
+      
+      // prepare to handle our ~~~ commands
+      reset_cmd_fsm();
+      
+      // enable interrupts (bit 3)
+      // outb(0x08, io_addr + 4);
+  } else {
+#ifdef NAUT_CONFIG_SERIAL_DEBUGGER
+      // debugger - raise interrupts on receive and line status (break)
+      outb(0x05, io_addr + 1);
+      // FIFOs off
+      outb(0, io_addr + 2);
+      // interrupt global enable
+      INFO_PRINT("Debug Interrupts enabled\n");
+#endif
+  }
 }
 
 static void serial_putchar_early (uchar_t c)
@@ -715,6 +807,8 @@ void
 serial_write (const char *buf) 
 {
     if (early_dev) {
+	//	ERROR_PRINT("Early dev: %p\n",early_dev);
+	//panic("Early Dev");
 	char c;
 	int flags = spin_lock_irq_save(&serial_lock);
 	while ((c=*buf)) { 
@@ -882,6 +976,42 @@ serial_printlevel (int level, const char * format, ...)
   }
 }
 
+#ifdef NAUT_CONFIG_SERIAL_DEBUGGER
+
+int serial_debugger_put(uint8_t c)
+{
+    if (!debug_io_addr) {
+        return -1;
+    }
+    
+    // Wait on THRE
+    while (!(inb(debug_io_addr + 5) & 0x20)) {
+    }
+
+    // pump data
+    outb(c, debug_io_addr + 0);
+    
+    return 0;
+}
+
+int serial_debugger_get(uint8_t *c)
+{
+    if (!debug_io_addr) {
+        return -1;
+    }
+    
+    // Wait on DR
+    while (!(inb(debug_io_addr + 5) & 0x01)) {
+    }
+    
+    // pump data
+    *c = inb(debug_io_addr + 0);
+    
+    return 0;
+
+}
+
+#endif
 
 static struct nk_dev_int devops = {
     .open=0,
@@ -902,22 +1032,22 @@ serial_early_init (void)
 
 #if NAUT_CONFIG_SERIAL_REDIRECT
 #if NAUT_CONFIG_SERIAL_REDIRECT_PORT == 1 
-  serial_init_addr(COM1_ADDR);
+  serial_init_addr(COM1_ADDR,0);
   register_irq_handler(COM1_3_IRQ, serial_irq_handler, NULL);
   com_irq = COM1_3_IRQ;
   nk_unmask_irq(com_irq);
 #elif NAUT_CONFIG_SERIAL_REDIRECT_PORT == 2 
-  serial_init_addr(COM2_ADDR);
+  serial_init_addr(COM2_ADDR,0);
   register_irq_handler(COM2_4_IRQ, serial_irq_handler, NULL);
   com_irq = COM2_4_IRQ;
   nk_unmask_irq(com_irq);
 #elif NAUT_CONFIG_SERIAL_REDIRECT_PORT == 3 
-  serial_init_addr(COM3_ADDR);
+  serial_init_addr(COM3_ADDR,0);
   register_irq_handler(COM1_3_IRQ, serial_irq_handler, NULL);
   com_irq = COM1_3_IRQ;
   nk_unmask_irq(com_irq);
 #elif NAUT_CONFIG_SERIAL_REDIRECT_PORT == 4
-  serial_init_addr(COM4_ADDR);
+  serial_init_addr(COM4_ADDR,0);
   register_irq_handler(COM2_4_IRQ, serial_irq_handler, NULL);
   com_irq = COM2_4_IRQ;;
   nk_unmask_irq(com_irq);
@@ -927,19 +1057,62 @@ serial_early_init (void)
 #endif
 
   serial_device_ready = 1;
+
+
+#if NAUT_CONFIG_SERIAL_DEBUGGER
+  
+#if NAUT_CONFIG_SERIAL_DEBUGGER_PORT == 1 
+  serial_init_addr(COM1_ADDR,1);
+  register_irq_handler(COM1_3_IRQ, debug_irq_handler, NULL);
+  nk_unmask_irq(COM1_3_IRQ);
+  INFO_PRINT("Debug Interrupts unmasked\n");
+  
+#elif NAUT_CONFIG_SERIAL_DEBUGGER_PORT == 2 
+  serial_init_addr(COM2_ADDR,1);
+  register_irq_handler(COM2_4_IRQ, debug_irq_handler, NULL);
+  nk_unmask_irq(COM2_4_IRQ);
+#elif NAUT_CONFIG_SERIAL_DEBUGGER_PORT == 3 
+  serial_init_addr(COM3_ADDR,1);
+  register_irq_handler(COM1_3_IRQ, debug_irq_handler, NULL);
+  nk_unmask_irq(COM1_3_IRQ);
+#elif NAUT_CONFIG_SERIAL_DEBUGGER_PORT == 4
+  serial_init_addr(COM4_ADDR,1);
+  register_irq_handler(COM2_4_IRQ, debug_irq_handler, NULL);
+  nk_unmask_irq(COM2_4_IRQ);
+#else
+#error Invalid serial port
+#endif
+#endif
+
 }
 
+#if NAUT_CONFIG_SERIAL_DEBUGGER && NAUT_CONFIG_SERIAL_DEBUGGER_PORT==NAUT_CONFIG_SERIAL_REDIRECT_PORT
+#error "Redirect Serial Port and Debugger Serial Port cannot be the same!"
+#endif
 
 void serial_init()
 {
     // post-facto register the generic serial output device
     nk_dev_register("serial-boot",NK_DEV_GENERIC,0,&devops,0);
-    
+
+#if NAUT_CONFIG_SERIAL_DEBUGGER
+    nk_dev_register("serial-debug", NK_DEV_GENERIC, 0, &devops, 0);
+#endif
+
     // attempt to find and setup all legacy serial devices 
+    // do not change the debugger port if we have one 
+#if !NAUT_CONFIG_SERIAL_DEBUGGER || NAUT_CONFIG_SERIAL_DEBUGGER_PORT!=1
     serial_init_one("serial0",COM1_ADDR,COM1_3_IRQ,0,&legacy[0]);
+#endif
+#if !NAUT_CONFIG_SERIAL_DEBUGGER || NAUT_CONFIG_SERIAL_DEBUGGER_PORT!=2
     serial_init_one("serial1",COM2_ADDR,COM2_4_IRQ,0,&legacy[1]);
+#endif
+#if !NAUT_CONFIG_SERIAL_DEBUGGER || NAUT_CONFIG_SERIAL_DEBUGGER_PORT!=3
     serial_init_one("serial2",COM3_ADDR,COM1_3_IRQ,0,&legacy[2]);
+#endif
+#if !NAUT_CONFIG_SERIAL_DEBUGGER || NAUT_CONFIG_SERIAL_DEBUGGER_PORT!=4
     serial_init_one("serial3",COM4_ADDR,COM2_4_IRQ,0,&legacy[3]);
+#endif
 
 #ifdef NAUT_CONFIG_SERIAL_REDIRECT
 #if NAUT_CONFIG_SERIAL_REDIRECT_PORT == 1 
diff --git a/src/nautilus/Makefile b/src/nautilus/Makefile
index b1d8434..6f64971 100644
--- a/src/nautilus/Makefile
+++ b/src/nautilus/Makefile
@@ -54,4 +54,6 @@ obj-$(NAUT_CONFIG_REAL_MODE_INTERFACE) += realmode.o
 
 obj-$(NAUT_CONFIG_ISOCORE) += isocore.o
 
+obj-$(NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING) += gdb-stub.o
+
 
diff --git a/src/nautilus/gdb-stub.c b/src/nautilus/gdb-stub.c
new file mode 100644
index 0000000..4bf0a92
--- /dev/null
+++ b/src/nautilus/gdb-stub.c
@@ -0,0 +1,1197 @@
+/* 
+ * This file is part of the Nautilus AeroKernel developed
+ * by the Hobbes and V3VEE Projects with funding from the 
+ * United States National  Science Foundation and the Department of Energy.  
+ *
+ * The V3VEE Project is a joint project between Northwestern University
+ * and the University of New Mexico.  The Hobbes Project is a collaboration
+ * led by Sandia National Laboratories that includes several national 
+ * laboratories and universities. You can find out more at:
+ * http://www.v3vee.org  and
+ * http://xstack.sandia.gov/hobbes
+ *
+ * Copyright (c) 2017, Peter Dinda <pdinda@northwestern.edu>
+ * Copyright (c) 2017, The V3VEE Project  <http://www.v3vee.org> 
+ *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
+ * All rights reserved.
+ *
+ * Author:  Peter Dinda <pdinda@northwestern.edu>
+ *
+ * This is free software.  You are permitted to use,
+ * redistribute, and modify it as specified in the file "LICENSE.txt".
+ */
+
+/*
+  This is an implementation of the gdb stub interface for Nautilus
+
+  It is influenced by the HP public domain code contributed to the 
+  gdb codebase (e.g., i386-stub.c). 
+
+  This is tested on gdb 7.11 on ubuntu:
+
+  GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1
+
+*/
+
+#include <nautilus/nautilus.h>
+#include <nautilus/msr.h>
+#include <dev/serial.h>
+#include <nautilus/idt.h>
+#include <nautilus/shutdown.h>
+#include <nautilus/scheduler.h>
+#include <nautilus/gdb-stub.h>
+
+/*
+  Note that gdb 7 does not have support for FSbase/GSbase, but
+  gdb 8 does. 
+
+  For 7:  SKIP_WRITE_FSGS=1, NEED_ORIG_RAX=1, NEED_FSGS_BASE=0
+  For 8:  ????  TODO
+*/
+
+#define SKIP_WRITE_FSGS 1   
+#define NEED_ORIG_RAX   1
+#define NEED_FSGS_BASE  0
+
+#ifdef NAUT_CONFIG_DEBUG_REMOTE_DEBUGGER
+#define DEBUG(fmt, args...)  DEBUG_PRINT("gdb: " fmt, ##args)
+#else
+#define DEBUG(fmt, args...)
+#endif
+
+#define ERROR(fmt, args...) ERROR_PRINT("gdb: " fmt, ##args)
+#define INFO(fmt, args...) INFO_PRINT("gdb: " fmt, ##args)
+
+static inline uint8_t get_gdb()
+{
+    uint8_t c;
+
+    serial_debugger_get(&c);
+    return c;
+}
+
+static inline void put_gdb(uint8_t c)
+{
+    serial_debugger_put(c);
+}
+
+
+static int     remote_debug = 0;
+/*  debug >  0 prints ill-formed commands in valid packets & checksum errors */
+
+static const char hexchars[]="0123456789abcdef";
+
+
+// This describes the register layout and ordering that GDB expects
+// it conforms to gdb/regformats/i386/amd64-linux.dat or whichever
+// architectural register description we want to use.
+// Note that the enhanced SSE/AVX register sets (ymms, zmms, etc)
+// are optional and are not included here.   Also note that
+// Although we have included the x87 and SSE registers (xmms) here, we
+// are not currently handling them (they are always zero and cannot be
+// set)
+//
+// ORIG_RAX is to support linux system call restarts.  We do need to handle
+// it, but it has no meaning in this kernel
+//
+// FSBASE/GSBASE are part of the gdb 8.0 register spec, and we should handle
+// them at some point - right now, it's very important that we do not
+// ever write FS or GS since theose also bork the base stuff, resulting in
+// mysterious failures relating to per-cpu variables
+typedef enum reg_name  {
+    RAX = 0, // 64 bit
+    RBX,
+    RCX,
+    RDX,
+    RSI,
+    RDI,
+    RBP,
+    RSP,
+    R8,
+    R9,
+    R10,
+    R11,
+    R12,
+    R13,
+    R14,
+    R15,
+
+    //# 16
+    RIP,     // @ + 8*16
+    EFLAGS,  // @ + 8*17, size 32
+    CS,      // @ + 8*17 + 4  segs are 32...
+    SS,
+    DS,
+    ES,
+    FS,
+    GS,
+
+    /* FIXME: We must have the basic x87 and SSE FP, but we will fake these */
+
+    // # 24
+    ST0,    // @ + 8*17 + 4*7 // STS are 80
+    ST1,    
+    ST2,    
+    ST3,    
+    ST4,    
+    ST5,    
+    ST6,
+    ST7,  
+    // #32
+    FCTRL,  // @ + 8*17 + 4*7 + 8*10 // these are 32
+    FSTAT,
+    FTAG,
+    FISEG,
+    FIOFF,
+    FOSEG,
+    FOOFF,
+    FOP,
+    
+    // #40
+    XMM0,  // @ + 8*17 + 4*7 + 8*10 + 8*4 // 128 bits
+    XMM1,
+    XMM2,
+    XMM3,
+    XMM4,
+    XMM5,
+    XMM6,
+    XMM7,
+    XMM8,
+    XMM9,
+    XMM10,
+    XMM11,
+    XMM12,
+    XMM13,
+    XMM14,
+    XMM15,
+    // #56
+    MXCSR, // @ + 8*17 + 4*7 + 8*10 + 8*4 + 16*16 // 32 bits
+    
+#if NEED_ORIG_RAX
+    // #57
+    ORIG_RAX, // @ @ + 8*17 + 4*7 + 8*10 + 8*4 + 16*16 + 4 // 64 bits
+#endif
+
+#if NEED_ORIG_FSGS_BASE
+    // #58
+    FS_BASE, // 64 bits
+    GS_BASE, // 64 bits
+#endif
+
+    /* We are ignoring AVX (ymms), and AVX2/512 (zmms)  groups 
+       Which would go here */
+} reg_name_t;
+
+#define PC RIP
+#define PS EFLAGS
+    
+#define MIN_REG_NAME RAX
+
+/* Number of bytes of registers.  */
+// not including FSBASE/GSBASE
+#define NUM_REG_BYTES_CORE (8*17 + 4*7 + 8*10 + 8*4 + 16*16 + 4)
+#if NEED_ORIG_RAX
+#if NEED_FSGS_BASE
+#define NUM_REG_BYTES (NUM_REG_BYTES_CORE + 8*3)
+#define MAX_REG_NAME GS_BASE
+#else
+#define NUM_REG_BYTES (NUM_REG_BYTES_CORE + 8*1)
+#define MAX_REG_NAME ORIG_RAX
+#endif
+#else
+// !NEED_ORIG_RAX
+#define NUM_REG_BYTES NUM_REG_BYTES_CORE
+#define MAX_REG_NAME MXCSR
+#endif 
+
+static char registers[NUM_REG_BYTES];
+
+
+
+static void gdb_reg_loc(reg_name_t n, int *off, int *size)
+{
+    if (n>=RAX && n<EFLAGS) {
+	*off = 8*(n-RAX);
+	*size = 8;
+    }
+    if (n>=EFLAGS && n<ST0) { 
+	*off = (8*17) + (n-EFLAGS)*4;
+	*size = 4;
+    }
+    if (n>=ST0 && n<=ST7) { 
+	*off = (8*17 + 4*7) + (n-ST0)*10;
+	*size= 10;
+    }
+    if (n>=FCTRL && n<=FOP) { 
+	*off = (8*17 + 4*7 + 8*10) + (n-FCTRL)*4;
+	*size = 4;
+    }
+    if (n>=XMM0 && n<=XMM15) { 
+	*off = (8*17 + 4*7 + 8*10 + 8*4) + (n-XMM0)*16;
+	*size = 16;
+    }
+    if (n==MXCSR) { 
+	*off = (8*17 + 4*7 + 8*10 + 8*4 + 16*16);
+	*size = 4;
+    }
+#if NEED_ORIG_RAX
+    if (n==ORIG_RAX) { 
+	*off = (8*17 + 4*7 + 8*10 + 8*4 + 16*16 + 4);
+	*size = 8;
+    }
+#if NEED_FSGS_BASE
+    if (n>=FS_BASE && n<=GS_BASE) { 
+	*off = (8*17 + 4*7 + 8*10 + 8*4 + 16*16 + 4 + 8) + (n-FS_BASE)*8;
+	*size = 8;
+    }
+#endif
+#endif
+}
+
+
+static void get_reg(reg_name_t r, char *val)
+{
+    int off, len;
+    gdb_reg_loc(r,&off,&len);
+    memcpy(val, registers+off,len);
+}
+
+static void set_reg(reg_name_t r, char *val)
+{
+    int off, len;
+    gdb_reg_loc(r,&off,&len);
+    memcpy(registers+off,val,len);
+}
+
+
+/* Address of a routine to RTE to if we get a memory fault.  */
+static void (*volatile mem_fault_routine) () = NULL;
+
+/* Indicate to caller of mem2hex or hex2mem that there has been an
+   error.  */
+static volatile int mem_err = 0;
+
+static void set_mem_err(void)
+{
+    mem_err = 1;
+}
+
+/* These are separate functions so that they are so short and sweet
+   that the compiler won't save any registers (if there is a fault
+   to mem_fault, they won't get restored, so there better not be any
+   saved).  */
+static inline int peek(char *addr)
+{
+    return *(volatile char *)addr;
+}
+
+static inline void poke(char *addr, int val)
+{
+    *(volatile char *)addr = val;
+}
+
+
+static int hex(char ch)
+{
+    if ((ch >= 'a') && (ch <= 'f')) {
+	return (ch - 'a' + 10);
+    }
+    if ((ch >= '0') && (ch <= '9')) {
+	return (ch - '0');
+    }
+    if ((ch >= 'A') && (ch <= 'F')) {
+	return (ch - 'A' + 10);
+    }
+    return (-1);
+}
+
+
+   
+
+/* convert the memory pointed to by mem into hex, placing result in buf */
+/* return a pointer to the last char put in buf (null) */
+/* If MAY_FAULT is non-zero, then we should set mem_err in response to
+   a fault; if zero treat a fault like any other fault in the stub.  */
+static char *mem2hex(char *mem, char *buf, int count, int may_fault)
+{
+    int i;
+    unsigned char ch;
+    
+    if (may_fault) {
+	mem_fault_routine = set_mem_err;
+    }
+
+    for (i = 0; i < count; i++) {
+	
+	ch = peek(mem++);
+	
+	if (may_fault && mem_err) {
+	    return (buf);
+	}
+
+	*buf++ = hexchars[ch >> 4];
+	*buf++ = hexchars[ch % 16];
+    }
+
+    *buf = 0;
+    if (may_fault) {
+	mem_fault_routine = NULL;
+    }
+
+    return (buf);
+}
+
+static char *byte_to_hex(char byte, char *buf, int may_fault)
+{
+    return mem2hex(&byte,buf,1,may_fault);
+}
+
+
+/* convert the hex array pointed to by buf into binary to be placed in mem */
+/* return a pointer to the character AFTER the last byte written */
+static char *hex2mem(char *buf, char *mem, int count, int may_fault)
+{
+    int i;
+    unsigned char ch;
+    
+    if (may_fault) {
+	mem_fault_routine = set_mem_err;
+    }
+
+    for (i = 0; i < count; i++) {
+	
+	ch = hex(*buf++) << 4;
+	ch = ch + hex(*buf++);
+
+	poke(mem++, ch);
+
+	if (may_fault && mem_err) {
+	    return (mem);
+	}
+    }
+
+    if (may_fault) {
+	mem_fault_routine = NULL;
+    }
+
+    return (mem);
+}
+
+static char *hex_to_byte(char *buf, char *byte, int may_fault)
+{
+    return hex2mem(buf,byte,1,may_fault);
+}
+
+
+
+static char *reg_val_to_hex(reg_name_t r, char *buf, int may_fault)
+{
+    int off, len;
+    gdb_reg_loc(r,&off,&len);
+    return mem2hex(registers+off,buf,len,may_fault);
+}
+
+// set = convert hex to register value
+static char *hex_to_reg_val(char *buf, reg_name_t r, int may_fault)
+{
+    int off, len;
+    gdb_reg_loc(r,&off,&len);
+    return hex2mem(buf,registers+off,len,may_fault);
+}
+
+// assume we have at most 256...
+static char *hex_to_reg_name(char *buf, reg_name_t *name, int may_fault)
+{
+    char n;
+    char *p = hex2mem(buf,&n,1,may_fault);
+    *name = (reg_name_t) n;
+    return p;
+}
+
+// assume we have at most 256...
+static char *reg_name_to_hex(reg_name_t r, char *buf, int may_fault)
+{
+    char n = (char) r;
+    return mem2hex(&n,buf,1,may_fault);
+}
+
+// What the GPRs pushed onto the stack by early_excp_common
+// or early_irq_common via SAVE_GPRS() (see thread.h and
+// excp_early.S) look like in memory
+struct excp_gpr_state {
+    uint64_t r15;
+    uint64_t r14;
+    uint64_t r13;
+    uint64_t r12;
+    uint64_t r11;
+    uint64_t r10;
+    uint64_t r9;
+    uint64_t r8;
+    uint64_t rbp;
+    uint64_t rdi;
+    uint64_t rsi;
+    uint64_t rdx;
+    uint64_t rcx;
+    uint64_t rbx;
+    uint64_t rax;
+} __packed;
+
+/*
+  Stack sees:
+
+  exception_context  <- we get ptr to lowest addr
+  GPRs saved by excp_early <- we want this, it's at -128
+ */
+
+#define EXCP_OFFSET_TO_GPRS -128
+
+
+static void snapshot_regs(excp_entry_t * excp)
+{
+    int i;
+
+    struct excp_gpr_state *r = (struct excp_gpr_state*)((addr_t)excp + EXCP_OFFSET_TO_GPRS);
+
+    memset(registers,0,NUM_REG_BYTES);
+
+    set_reg(RAX,(char*)&r->rax);
+    set_reg(RBX,(char*)&r->rbx);
+    set_reg(RCX,(char*)&r->rcx);
+    set_reg(RDX,(char*)&r->rdx);
+    set_reg(RSI,(char*)&r->rsi);
+    set_reg(RDI,(char*)&r->rdi);
+    set_reg(RBP,(char*)&r->rbp);
+    set_reg(R8, (char*)&r->r8);
+    set_reg(R9, (char*)&r->r9);
+    set_reg(R10,(char*)&r->r10);
+    set_reg(R11,(char*)&r->r11);
+    set_reg(R12,(char*)&r->r12);
+    set_reg(R13,(char*)&r->r13);
+    set_reg(R14,(char*)&r->r14);
+    set_reg(R15,(char*)&r->r15);
+    
+    // get critical data directly from the exception structure
+    set_reg(CS,(char*)&excp->cs);
+    set_reg(RIP,(char*)&excp->rip);
+    set_reg(SS,(char*)&excp->ss);
+    set_reg(RSP,(char*)&excp->rsp);
+    set_reg(EFLAGS,(char*)&excp->rflags);
+
+    // and DS, GS, FS, ES
+    uint32_t val=0;
+
+    __asm__ __volatile__ ("movw %%ds, %0" : "=m"(val) : : "memory");
+    val &= 0xffff;
+    set_reg(DS,(char*)&val);
+    __asm__ __volatile__ ("movw %%gs, %0" : "=m"(val) : : "memory");
+    val &= 0xffff;
+    set_reg(GS,(char*)&val);
+    __asm__ __volatile__ ("movw %%fs, %0" : "=m"(val) : : "memory");
+    val &= 0xffff;
+    set_reg(FS,(char*)&val);
+    __asm__ __volatile__ ("movw %%es, %0" : "=m"(val) : : "memory");
+    val &= 0xffff;
+    set_reg(ES,(char*)&val);
+
+#if NEED_ORIG_RAX
+    set_reg(ORIG_RAX,(char*)&r->rax);
+#endif
+
+#if NEED_FSGS_BASE
+    uint64_t base;
+    base = msr_read(MSR_FS_BASE);
+    set_reg(FS_BASE, (char*)&base);
+    base = msr_read(MSR_GS_BASE);
+    set_reg(GS_BASE, (char*)&base);
+#endif
+
+    // FIXME - copy out floating point state
+
+}
+
+static void update_regs(excp_entry_t * excp)
+{
+    int i;
+
+    struct excp_gpr_state *r = (struct excp_gpr_state*)((addr_t)excp + EXCP_OFFSET_TO_GPRS);
+
+    get_reg(RAX,(char*)&r->rax);
+    get_reg(RBX,(char*)&r->rbx);
+    get_reg(RCX,(char*)&r->rcx);
+    get_reg(RDX,(char*)&r->rdx);
+    get_reg(RSI,(char*)&r->rsi);
+    get_reg(RDI,(char*)&r->rdi);
+    get_reg(RBP,(char*)&r->rbp);
+    get_reg(R8, (char*)&r->r8);
+    get_reg(R9, (char*)&r->r9);
+    get_reg(R10,(char*)&r->r10);
+    get_reg(R11,(char*)&r->r11);
+    get_reg(R12,(char*)&r->r12);
+    get_reg(R13,(char*)&r->r13);
+    get_reg(R14,(char*)&r->r14);
+    get_reg(R15,(char*)&r->r15);
+    
+    // get critical data directly from the exception structure
+    get_reg(CS,(char*)&excp->cs);
+    get_reg(RIP,(char*)&excp->rip);
+    get_reg(SS,(char*)&excp->ss);
+    get_reg(RSP,(char*)&excp->rsp);
+    get_reg(EFLAGS,(char*)&excp->rflags);
+
+    // and DS, ES
+    uint32_t val=0;
+
+    get_reg(DS,(char*)&val);
+    val &= 0xffff;
+    __asm__ __volatile__ ("movw %0, %%ds" : : "m"(val) : "memory");
+    get_reg(ES,(char*)&val);
+    val &= 0xffff;
+    __asm__ __volatile__ ("movw %0, %%es" : : "m"(val) : "memory");
+
+    // Optionally update the FS/GS regs
+    // note that if the target is using the GSBASE and FSBASE
+    // MSRs, this could screw them up if we are also not updating
+    // FSBASE/GSBASE MSRs *AFTER* this
+    // We also need to be sure that nothing is using gs or fs between
+    // these updates and the msr writes... 
+#if SKIP_WRITE_FSGS
+    // nothing
+#else
+    get_reg(GS,(char*)&val);
+    val &= 0xffff;
+    __asm__ __volatile__ ("movw %0, %%gs" : : "m"(val) : "memory");
+    get_reg(FS,(char*)&val);
+    val &= 0xffff;
+    __asm__ __volatile__ ("movw %0, %%fs" : : "m"(val) : "memory");
+#endif
+
+    
+#if NEED_FSGS_BASE
+    uint64_t base;
+    get_reg(FS_BASE, (char*)&base);
+    msr_write(MSR_FS_BASE,base);
+    get_reg(GS_BASE, (char*)&base);
+    msr_write(MSR_GS_BASE,base);
+#endif
+    // What is the point of ORIG_RAX, should this be RAX on exit?
+
+    // FIXME - copy out floating point state
+}
+
+
+/************************************************************************/
+/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
+/* at least NUMREGBYTES*2 are needed for register packets */
+#define BUFMAX (NUM_REG_BYTES*16)
+
+
+#define STACKSIZE 10000
+int remcomStack[STACKSIZE/sizeof(int)];
+static int* stackPtr = &remcomStack[STACKSIZE/sizeof(int) - 1];
+
+/***************************  ASSEMBLY CODE MACROS *************************/
+/* 									   */
+
+extern void
+return_to_prog ();
+
+
+
+/* Put the error code here just in case the user cares.  */
+static int gdb_i386errcode;
+/* Likewise, the vector number here (since GDB only gets the signal
+   number through the usual means, and that's not very specific).  */
+static int gdb_i386vector = -1;
+
+static void _returnFromException()
+{
+    //    return_to_prog();
+}
+
+
+
+// These should probably be protected or replicated to
+// since only one cpu at a time should be talking to gdb
+static char remcomInBuffer[BUFMAX];
+static char remcomOutBuffer[BUFMAX];
+
+/* scan for the sequence $<data>#<checksum>     */
+
+static unsigned char *getpacket(void)
+{
+    unsigned char *buffer = &remcomInBuffer[0];
+    unsigned char checksum;
+    unsigned char xmitcsum;
+    int count;
+    char ch;
+    
+    while (1)  {
+	/* wait around for the start character, ignore all other characters */
+	while ((ch = get_gdb()) != '$') {
+	}
+	
+    retry:
+	checksum = 0;
+	xmitcsum = -1;
+	count = 0;
+	
+	/* now, read until a # or end of buffer is found */
+	while (count < BUFMAX - 1) {
+	    ch = get_gdb();
+	    if (ch == '$') {
+		goto retry;
+	    }
+	    if (ch == '#') {
+		break;
+	    }
+	    checksum = checksum + ch;
+	    buffer[count] = ch;
+	    count = count + 1;
+	}
+	buffer[count] = 0;
+
+	if (ch == '#') {
+	    ch = get_gdb();
+	    xmitcsum = hex(ch) << 4;
+	    ch = get_gdb();
+	    xmitcsum += hex(ch);
+	    
+	    if (checksum != xmitcsum) {
+
+		if (remote_debug){
+		    ERROR("bad checksum.  My count = 0x%x, sent=0x%x. buf=%s\n",
+			  checksum, xmitcsum, buffer);
+		}
+		put_gdb('-');	/* failed checksum */
+
+	    } else {
+
+		put_gdb('+');	/* successful transfer */
+		
+		/* if a sequence char is present, reply the sequence ID */
+		if (buffer[2] == ':') {
+		    put_gdb(buffer[0]);
+		    put_gdb(buffer[1]);
+		    
+		    return &buffer[3];
+		}
+		
+		return &buffer[0];
+	    }
+	}
+    }
+}
+
+/* send the packet in buffer.  */
+
+static void putpacket(unsigned char *buffer)
+{
+    unsigned char checksum;
+    int count;
+    char ch;
+    
+    /*  $<packet info>#<checksum>.  */
+    do {
+	
+	put_gdb('$');
+	checksum = 0;
+	count = 0;
+	
+	while ((ch = buffer[count])) {
+	    put_gdb(ch);
+	    checksum += ch;
+	    count += 1;
+	}
+	
+	put_gdb('#');
+	put_gdb(hexchars[checksum >> 4]);
+	put_gdb(hexchars[checksum % 16]);
+	
+    } while (get_gdb() != '+');
+}
+
+static void debug_error(char *format, char *parm)
+{
+    if (remote_debug) {
+	ERROR("debug error %s with parameter %s\n", format, parm);
+    }
+}
+
+
+
+/* this function takes the 386 exception vector and attempts to
+   translate this number into a unix compatible signal value */
+static int compute_signal (int exceptionVector)
+{
+    int sigval;
+    switch (exceptionVector) {
+    case DE_EXCP:
+	sigval = 8;
+	break;			/* divide by zero */
+    case DB_EXCP:
+	sigval = 5;
+	break;			/* debug exception */
+	
+   /* there is no NMI_INT case */
+	
+    case BP_EXCP:
+	sigval = 5;
+	break;			/* breakpoint */
+    case OF_EXCP:
+	sigval = 16;
+	break;			/* into instruction (overflow) */
+    case BR_EXCP:
+	sigval = 16;
+	break;			/* bound instruction */
+    case UD_EXCP:
+	sigval = 4;
+	break;			/* Invalid opcode */
+    case NM_EXCP:
+	sigval = 8;
+	break;			/* coprocessor not available */
+    case DF_EXCP:
+	sigval = 7;
+	break;			/* double fault */
+    case CP_EXCP:
+	sigval = 11;
+	break;			/* coprocessor segment overrun */
+    case TS_EXCP:
+	sigval = 11;
+	break;			/* Invalid TSS */
+    case NP_EXCP:
+	sigval = 11;
+	break;			/* Segment not present */
+    case SS_EXCP:
+	sigval = 11;
+	break;			/* stack exception */
+    case GP_EXCP:
+	sigval = 11;
+	break;			/* general protection */
+    case PF_EXCP:
+	sigval = 11;
+	break;			/* page fault */
+    case MF_EXCP:
+	sigval = 7;
+	break;			/* coprocessor error */
+    case AC_EXCP:
+	sigval = 7;             /* alignment check */
+	break;
+    case MC_EXCP:               /* machine check */
+	sigval = 7;
+	break;
+    case XM_EXCP:              
+	sigval = 7;             /* SIMD FPU */
+	break;
+    case VE_EXCP:
+	sigval = 7;             /* virtualization */
+	break;
+    case SE_EXCP:
+	sigval = 7;             /* security */
+	break;
+    default:
+	sigval = 7;		/* "software generated" */
+    }
+    
+    return (sigval);
+}
+
+/**********************************************/
+/* WHILE WE FIND NICE HEX CHARS, BUILD AN INT */
+/* RETURN NUMBER OF CHARS PROCESSED           */
+/**********************************************/
+static int hex2int(char **ptr, int *intValue)
+{
+    int numChars = 0;
+    int hexValue;
+    
+    *intValue = 0;
+    
+    while (**ptr) {
+	
+	hexValue = hex(**ptr);
+	
+	if (hexValue >= 0) {
+	    *intValue = (*intValue << 4) | hexValue;
+	    numChars++;
+	} else {
+	    break;
+	}
+	
+	(*ptr)++;
+    }
+    
+    return (numChars);
+}
+
+/**********************************************/
+/* WHILE WE FIND NICE HEX CHARS, BUILD A LONG */
+/* RETURN NUMBER OF CHARS PROCESSED           */
+/**********************************************/
+static int hex2long(char **ptr, long *longValue)
+{
+    int numChars = 0;
+    int hexValue;
+    
+    *longValue = 0;
+
+    while (**ptr) {
+	
+	hexValue = hex(**ptr);
+      
+	if (hexValue >= 0) {
+	    *longValue = (*longValue << 4) | hexValue;
+	    numChars++;
+	} else {
+	    break;
+	}
+	
+	(*ptr)++;
+    }
+
+    return (numChars);
+}
+
+static struct entry {
+    int (*handler)(excp_entry_t * excp, excp_vec_t vec, addr_t fault_addr, void * state_addr);
+    void *state;
+} orig_exception_state[NUM_EXCEPTIONS];
+	
+
+
+/*
+ * This function does all command procesing for interfacing to gdb.
+ */
+static int handle_exception(excp_entry_t * excp, excp_vec_t vec, addr_t fault_addr, void * state_addr)
+{
+    int sigval, stepping;
+    uint64_t addr, length;
+    uint64_t orig_rip;
+    int new_rip=0;
+
+    char *in;
+    char *out;
+
+    // everyone waits on us
+    // note this is a noop until the scheduler is fully active on all cpus
+    // other CPUs will be forced into the scheduler via an interrupt
+    // which will not fire an entry into this handler on them
+    //    nk_sched_stop_world();
+    
+    DEBUG("entry - vector %x, error_code=%lx rip=%lx:%lx fault_addr=%lx\n", 
+	  vec, excp->error_code, excp->cs, excp->rip, fault_addr);
+
+    snapshot_regs(excp);
+
+    get_reg(RIP,(char*)&orig_rip);
+    
+    gdb_i386vector = vec;
+    
+    if (remote_debug) {
+	uint64_t rip;
+	uint32_t eflags;
+
+	get_reg(RIP,(char*)&rip);
+	get_reg(EFLAGS,(char*)&eflags);
+
+	INFO("vector=%d, rip=0x%lx, eflags=0x%x\n",
+	     vec, rip, eflags);
+    }
+    
+    /* reply to host that an exception has occurred */
+    sigval = compute_signal(vec);
+    
+    out = remcomOutBuffer;
+    
+    *out++ = 'T';	/* notify gdb with signo, PC, BP and SP */
+    out = byte_to_hex(sigval,out,0);
+
+    out = reg_name_to_hex(RSP,out,0);
+    *out++ = ':';
+    out = reg_val_to_hex(RSP,out,0);
+    *out++ = ';';
+
+    out = reg_name_to_hex(RBP,out,0);
+    *out++ = ':';
+    out = reg_val_to_hex(RBP,out,0);
+    *out++ = ';';
+
+    out = reg_name_to_hex(RIP,out,0);
+    *out++ = ':';
+    out = reg_val_to_hex(RIP,out,0);
+    *out++ = ';';
+
+    *out = '\0';
+
+    DEBUG("Sending Debugger \"%s\"\n",remcomOutBuffer);
+
+    putpacket(remcomOutBuffer);
+    
+    stepping = 0;
+
+    while (1 == 1)  {
+
+	out = remcomOutBuffer;
+
+	*out = 0;
+
+	in = getpacket();
+
+	DEBUG("Received from debugger \"%s\"\n",in);
+
+	switch (*in++) {
+
+	case '?':
+
+	    DEBUG("last signal request\n");
+	    *out++ = 'S';
+	    out = byte_to_hex(sigval,out,0);
+	    *out++ = 0;
+	    break;
+
+	case 'd':
+
+	    DEBUG("toggle remote debug request\n");
+	    remote_debug = !(remote_debug);	/* toggle debug flag */
+	    break;
+	    
+	case 'g':		/* return the value of the CPU registers */
+	    
+	    DEBUG("get registers request\n");
+	    
+	    out = mem2hex(registers, out, NUM_REG_BYTES, 0);
+
+	  break;
+
+	case 'G':		/* set the value of the CPU registers - return OK */
+
+	    DEBUG("set registers request\n");
+	    
+	    in = hex2mem(in, registers, NUM_REG_BYTES, 0);
+
+	    strcpy(out,"OK");
+
+	  break;
+
+	case 'P':	{	/* set the value of a single CPU register - return OK */
+
+	    reg_name_t regname;
+
+	    DEBUG("set specific register request\n");
+
+	    if (hex2int(&in, (int*) &regname) && *in++ == '=') {
+		DEBUG("set register %d\n",regname);
+	    }
+
+	    if (regname >= MIN_REG_NAME && regname <= MAX_REG_NAME ) {
+		in = hex_to_reg_val(in, regname, 0);
+		strcpy(out, "OK");
+		break;
+	    }
+	    
+	    // error
+	    strcpy(out, "E01");
+	}
+	    break;
+
+	  /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
+
+	case 'm':
+
+	  /* TRY TO READ %x,%x.  IF WE SUCCEED, SET IN = 0 */
+	    DEBUG("read memory range request\n");
+
+	    if (hex2long(&in, &addr)) {
+
+		if (*(in++) == ',') {
+
+		    if (hex2long(&in, &length)) {
+			in = 0 ; // signal to following error test
+			mem_err = 0;
+			// intentionally not advancing out here
+			// since we may have a memory error
+			mem2hex((char *) addr, out, length, 1);
+			if (mem_err) {
+			    strcpy (out,"E03");
+			    debug_error ("memory fault",0);
+			}
+		    }
+		}
+	    } 
+
+	    if (in) {
+		strcpy(out, "E01");
+	    }
+	    
+	    break;
+
+	    /* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
+
+	case 'M':
+	    
+	    /* TRY TO WRITE '%x,%x:'.  IF SUCCEED, SET IN = 0 */
+
+	    DEBUG("write memory range request\n");
+
+	    if (hex2long(&in, &addr)) {
+
+		if (*(in++) == ',') {
+
+		    if (hex2long(&in, &length)) {
+
+			if (*(in++) == ':') {
+
+			    mem_err = 0;
+			    in = hex2mem(in, (char *) addr, length, 1);
+
+			    if (mem_err) {
+				strcpy(out, "E03");
+				debug_error ("memory fault",0);
+
+			    }  else  {
+				strcpy (remcomOutBuffer, "OK");
+			    }
+
+			    in = 0;
+			}
+		    }
+		}
+	    }
+			
+	    if (in) {
+	      strcpy (out, "E02");
+	    }
+	    
+	    break;
+
+	    /* sAA..AA   Step one instruction from AA..AA(optional) */
+	    /* cAA..AA    Continue at address AA..AA(optional) */
+
+	case 's':
+	    DEBUG("set single stepping request\n");
+	    stepping = 1;
+
+	    // intentional fall through here...
+
+	case 'c':
+	  /* try to read optional parameter, pc unchanged if no parm */
+
+	    if (hex2long (&in, &addr)) {
+
+		set_reg(RIP,(char*)&addr);
+
+		new_rip = 1;
+	    }
+
+	    DEBUG("continue at address %lx request (stepping=%d)\n", addr, stepping);
+
+	    uint32_t eflags;
+
+	    get_reg(EFLAGS, (char*)&eflags);
+	    
+	    eflags &= 0xfffffeff;
+
+	    /* set the trace bit if we're stepping */
+	    if (stepping) {
+		eflags |= 0x100;
+	    }
+
+	    set_reg(EFLAGS, (char*)&eflags);
+
+	    goto out;
+
+	    break;
+
+	  /* kill the program */
+	case 'k':		/* do nothing */
+	    INFO("kill request - rebooting\n");
+	    reboot();
+
+	  break;
+
+	default:
+	    DEBUG("Ignoring unknown request \"%s\"\n",in-1);
+	    break;
+	}			/* switch */
+
+	/* reply to the request */
+
+	DEBUG("Replying with \"%s\"\n",remcomOutBuffer);
+	putpacket(remcomOutBuffer);
+    }
+
+
+
+ out:    
+
+    update_regs(excp);
+
+    switch (vec) { 
+    case DB_EXCP:
+	DEBUG("Continuing from a debug exception (DB_EXCP) so not invoking nested handler\n");
+	DEBUG("excp->rflags = %x\n", excp->rflags);
+	//	nk_sched_start_world();
+	return 0;
+	break; 
+    case BP_EXCP:
+	DEBUG("Continuing from a breakpoint (int3/BP_EXCP) so not invoking nested handler\n");
+	DEBUG("excp->rflags = %x\n", excp->rflags);
+	//nk_sched_start_world();
+	return 0;
+	break; 
+	
+    default:
+	// this needs to be wrapped so as to unwind the stack
+	// so it looks like a direct invocation of the next handler
+	DEBUG("Invoking original handler\n");
+	//nk_sched_start_world();
+	return orig_exception_state[vec].handler(excp, vec, fault_addr, 
+						 orig_exception_state[vec].state);
+    }
+
+}
+
+// Should be invoked by cpu 0, and assumes 
+// that all other cpus have the same installed exception handlers and state
+// hooking exceptions for debugging should happen AFTER ALL EXCEPTION
+// HANDLERS HAVE BEEN INSTALLED
+static void hook_exceptions()
+{
+    int i;
+    for (i=0;i<NUM_EXCEPTIONS;i++) { 
+	idt_get_entry(i,
+		      (ulong_t*)&orig_exception_state[i].handler,
+		      (ulong_t*)&orig_exception_state[i].state);
+    }
+
+    for (i=0;i<NUM_EXCEPTIONS;i++) { 
+	idt_assign_entry(i,(ulong_t)handle_exception,(ulong_t)0);
+    }
+
+}
+
+
+
+int nk_gdb_init()
+{
+    stackPtr = &remcomStack[STACKSIZE / sizeof (int) - 1];
+    
+    hook_exceptions();
+    
+    INFO("inited\n");
+
+#ifdef NAUT_CONFIG_ATTACH_REMOTE_DEBUGGER_AT_BOOT
+    INFO("attaching to debugger now\n");
+    nk_gdb_breakpoint_here();
+#endif
+    
+    return 0;
+}
+
+int nk_gdb_init_ap()
+{
+    // nothing for this to do at the moment
+    INFO("inited (as AP)\n");
+    nk_gdb_breakpoint_here();
+    return 0;
+}
+
diff --git a/src/nautilus/scheduler.c b/src/nautilus/scheduler.c
index 2a165df..5612acb 100644
--- a/src/nautilus/scheduler.c
+++ b/src/nautilus/scheduler.c
@@ -137,6 +137,8 @@ struct nk_sched_global_state {
     int                  reaping;
 };
 
+static volatile int scheduler_ready = 0;
+
 static volatile uint64_t sync_count=0;
 static volatile uint64_t tsc_start=-1ULL;
 
@@ -690,11 +692,19 @@ void nk_sched_map_threads(int cpu, void (func)(struct nk_thread *t, void *state)
 
 void nk_sched_stop_world()
 {
+    // this must happen before any of the lookups...
+    if (!scheduler_ready) {
+      return;
+    }
+
+    
     uint64_t num_cpus = nk_get_num_cpus();
     uint64_t my_cpu_id = my_cpu_id();
     uint64_t stopper = my_cpu_id+1;
     uint64_t i;
 
+
+    
     // scheduler cannot stop us
     // note that an interrupt will still land us in the
     // stop-world test in need_resched
@@ -722,6 +732,10 @@ void nk_sched_stop_world()
 
 void nk_sched_start_world()
 {
+    if (!scheduler_ready) {
+      return;
+    }
+
     // indicate that we are restarting the world
     __sync_fetch_and_and(&stopping,0);
 
@@ -1575,8 +1589,19 @@ static void set_timer(rt_scheduler *scheduler, rt_thread *thread, uint64_t now)
     scheduler->tsc.start_time = now;
     scheduler->tsc.set_time = MIN(next_arrival,next_preempt);
 
+    // minus slack, probably... 
+    // should capture the time right at this point instead of using nowe
+    //
+    //    absolute time            absolute time
+    //   now(insched) .....        set_time
+    //        now(here) ....            now(here) + (set_time - now(insched)) 
+    //                                  (Wakeup is late) 
     uint32_t ticks = apic_realtime_to_ticks(apic, 
 					    scheduler->tsc.set_time - now + scheduler->slack);
+
+    // More likely
+    //     uint32_t ticks = apic_realtime_to_ticks(apic, 
+    // scheduler->tsc.set_time - cur_time() - scheduler->slack);
     
     if (cur_time() >= scheduler->tsc.set_time) {
 	DEBUG("Time of next clock has already passed (cur_time=%llu, set_time=%llu)\n",
@@ -3531,6 +3556,10 @@ void nk_sched_start()
 
     DEBUG("Startup done main tid=%lu\n",main->tid);
 
+    if (my_cpu->is_bsp) { 
+      scheduler_ready = 1;
+    }
+
 }
     
 
diff --git a/src/nautilus/smp.c b/src/nautilus/smp.c
index 4ff5055..7b196c4 100644
--- a/src/nautilus/smp.c
+++ b/src/nautilus/smp.c
@@ -38,6 +38,11 @@
 #include <dev/ioapic.h>
 #include <dev/apic.h>
 
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING 
+#include <nautilus/gdb-stub.h>
+#endif
+
+
 #ifndef NAUT_CONFIG_DEBUG_SMP
 #undef DEBUG_PRINT
 #define DEBUG_PRINT(fmt, args...)
@@ -290,6 +295,13 @@ smp_ap_setup (struct cpu * core)
 
     // set GS base (for per-cpu state)
     msr_write(MSR_GS_BASE, (uint64_t)core_addr);
+
+#ifdef NAUT_CONFIG_ENABLE_REMOTE_DEBUGGING 
+    if (nk_gdb_init_ap() != 0) {
+        ERROR_PRINT("Could not initialize remote debugging for core %u\n", core->id);
+	return -1;
+    }
+#endif
     
     apic_init(core);
 
-- 
2.7.4

