diff --git a/Kconfig b/Kconfig
index 81b22fb..612aac6 100644
--- a/Kconfig
+++ b/Kconfig
@@ -113,6 +113,17 @@ menu "Platform/Arch Options"
         depends on PALACIOS
         default 0
         
+config NEWLIB
+    	bool "Use Newlib libc"
+        depends on X86_64_HOST
+        default 0
+    config NEWLIB_DIR
+        depends on NEWLIB
+        string "Path to Newlib install tree"
+            default "/home/parallels/newlib/"
+            help
+		Path to the Newlib libc build.
+
 endmenu
 
 menu "Nautilus AeroKernel Build Config"
diff --git a/Makefile b/Makefile
index 12534af..9337cd3 100644
--- a/Makefile
+++ b/Makefile
@@ -492,7 +492,6 @@ scripts_basic: include/autoconf.h
 core-y          := src/
 libs-y		    := lib/ 
 
-
 ifeq ($(dot-config),1)
 # In this section, we need .config
 
@@ -565,6 +564,13 @@ ifdef NAUT_CONFIG_PALACIOS
 # image attachement here somewhere for testing, probably via a linker script
 endif
 
+ifdef NAUT_CONFIG_NEWLIB
+  NEWLIB_DIR=$(subst ",,$(NAUT_CONFIG_NEWLIB_DIR))
+  CFLAGS += -I$(NEWLIB_DIR)/x86_64-pc-nautilus/include
+  libs-y += $(NEWLIB_DIR)/x86_64-pc-nautilus/lib/libc.a   #$(NEWLIB_DIR)/x86_64-pc-nautilus/lib/libnosys.a $(NEWLIB_DIR)/x86_64-pc-nautilus/lib/libg.a $(NEWLIB_DIR)/x86_64-pc-nautilus/lib/libm.a
+  LDFLAGS         +=  --whole-archive -dp
+endif
+
 
 # The all: target is the default when no target is given on the
 # command line.
diff --git a/include/nautilus/fs.h b/include/nautilus/fs.h
index e7c6b53..e8a3bd1 100644
--- a/include/nautilus/fs.h
+++ b/include/nautilus/fs.h
@@ -58,6 +58,7 @@ struct nk_fs_int {
     void  (*close_file)(void *state, void *file);
 };
 
+
 // This is the class for a filesystem.  It should be the first
 // member of any specific type of filesystem
 struct nk_fs {
diff --git a/include/nautilus/libccompat.h b/include/nautilus/libccompat.h
index 8e72d94..f9258ee 100644
--- a/include/nautilus/libccompat.h
+++ b/include/nautilus/libccompat.h
@@ -1,17 +1,17 @@
-/* 
+/*
  * This file is part of the Nautilus AeroKernel developed
- * by the Hobbes and V3VEE Projects with funding from the 
- * United States National  Science Foundation and the Department of Energy.  
+ * by the Hobbes and V3VEE Projects with funding from the
+ * United States National  Science Foundation and the Department of Energy.
  *
  * The V3VEE Project is a joint project between Northwestern University
  * and the University of New Mexico.  The Hobbes Project is a collaboration
- * led by Sandia National Laboratories that includes several national 
+ * led by Sandia National Laboratories that includes several national
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
  * http://xtack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
- * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
+ * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org>
  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
  * All rights reserved.
  *
@@ -32,7 +32,7 @@ extern "C" {
 #ifndef NAUT_CONFIG_SILENCE_UNDEF_ERR
 #define UNDEF_FUN_ERR() ERROR_PRINT("Function (%s) undefined\n", __func__)
 #else
-#define UNDEF_FUN_ERR() 
+#define UNDEF_FUN_ERR()
 #endif
 
 #define RAND_MAX    2147483647
diff --git a/include/nautilus/naut_string.h b/include/nautilus/naut_string.h
index 2f64346..167706b 100644
--- a/include/nautilus/naut_string.h
+++ b/include/nautilus/naut_string.h
@@ -78,6 +78,7 @@ static inline unsigned char __toupper(unsigned char c)
 
 
 #ifdef NAUT_CONFIG_USE_NAUT_BUILTINS
+
 void * memcpy (void * dst, const void * src, size_t n);
 int memcmp (const void * s1_, const void * s2_, size_t n);
 void * memset (void * dst, char c, size_t n);
@@ -143,7 +144,7 @@ char * strstr (const char * haystack, const char * needle);
       src_ep += 1;                                \
     } while (0)
 
-#else
+#else // ndef USE BUILTINS
 
 #include <stddef.h>
 
@@ -163,12 +164,13 @@ char * strstr (const char * haystack, const char * needle);
 #define strrchr __builtin_strrchr
 #define strpbrk __builtin_strpbrk
 
-#endif
+#endif  // USE BUILTINS
 
 int atoi (const char * buf);
-int strtoi (const char * nptr, char ** endptr);
 long strtol(const char * str, char ** endptr, int base);
 long atol(const char *nptr);
+
+int strtoi (const char * nptr, char ** endptr);
 uint64_t atox (const char * buf);
 uint64_t strtox (const char * nptr, char ** endptr);
 void str_toupper (char * s);
diff --git a/include/nautilus/printk.h b/include/nautilus/printk.h
index dcacda6..733a960 100644
--- a/include/nautilus/printk.h
+++ b/include/nautilus/printk.h
@@ -31,6 +31,13 @@ extern "C" {
 #include <stdarg.h>
 #include <nautilus/naut_types.h>
 
+  int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+  int vsprintf(char *buf, const char *fmt, va_list args);
+  int sprintf(char * buf, const char *fmt, ...);
+  int snprintf(char * buf, size_t size, const char *fmt, ...);
+  int vsscanf(const char * buf, const char * fmt, va_list args);
+  int sscanf(const char * buf, const char * fmt, ...);
+  
 void panic (const char * fmt, ...);
 int printk (const char * fmt, ...);
 int vprintk(const char * fmt, va_list args);
@@ -43,14 +50,8 @@ int strict_strtoul(const char *cp, unsigned int base, unsigned long *res);
 int strict_strtol(const char *cp, unsigned int base, long *res);
 int strict_strtoull(const char *cp, unsigned int base, unsigned long long *res);
 int strict_strtoll(const char *cp, unsigned int base, long long *res);
-int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
 int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
-int snprintf(char * buf, size_t size, const char *fmt, ...);
 int scnprintf(char * buf, size_t size, const char *fmt, ...);
-int vsprintf(char *buf, const char *fmt, va_list args);
-int sprintf(char * buf, const char *fmt, ...);
-int vsscanf(const char * buf, const char * fmt, va_list args);
-int sscanf(const char * buf, const char * fmt, ...);
 
 void warn_slowpath(const char * file, int line, const char * fmt, ...);
 
diff --git a/src/arch/x64/init.c b/src/arch/x64/init.c
index 05db05c..718bee6 100644
--- a/src/arch/x64/init.c
+++ b/src/arch/x64/init.c
@@ -346,6 +346,12 @@ init (unsigned long mbd,
 
     nk_rand_init(naut->sys.cpus[0]);
 
+    extern long simple_strtol(const char*, char**, unsigned int);
+    long 
+      strtol (const char * str, char ** endptr, int base)
+    {
+      return simple_strtol(str, endptr, base);
+}
     ps2_init(naut);
 
     pci_init(naut);
@@ -397,6 +403,8 @@ init (unsigned long mbd,
 
 	nk_sched_start();
 
+  nvram_init();
+
     sti();
 
     /* interrupts are now on */
diff --git a/src/asm/setjmp_low.S b/src/asm/setjmp_low.S
index 4a11372..b9be09d 100644
--- a/src/asm/setjmp_low.S
+++ b/src/asm/setjmp_low.S
@@ -37,3 +37,4 @@ ENTRY(longjmp)
 	movq 0x38(%rdi), %rdx // soon to be rip
 	jmp  *%rdx
 
+// Also defined in newlib, but using this for now
diff --git a/src/dev/Kconfig b/src/dev/Kconfig
index 846fac9..fd89138 100644
--- a/src/dev/Kconfig
+++ b/src/dev/Kconfig
@@ -92,6 +92,13 @@ config DEBUG_PIT
     help
       Turn on debug prints for the i8253/8254 PIT
 
+config DEBUG_NVRAM
+    bool "Debug NVRAM"
+    depends on DEBUG_PRINTS
+    default n
+    help
+      Turn on debug prints for the NVRAM
+
 config HPET
     bool "HPET Support"
     depends on X86_64_HOST
diff --git a/src/dev/Makefile b/src/dev/Makefile
index 43ae0bc..0d0f423 100644
--- a/src/dev/Makefile
+++ b/src/dev/Makefile
@@ -1,6 +1,7 @@
 obj-y += apic.o \
 	 ioapic.o \
 	 i8254.o \
+	 nvram.o \
 	 ps2.o \
 	 pci.o \
          vga.o \
diff --git a/src/nautilus/Makefile b/src/nautilus/Makefile
index b7f8e1e..567b891 100644
--- a/src/nautilus/Makefile
+++ b/src/nautilus/Makefile
@@ -29,7 +29,6 @@ obj-y += \
 	cpu.o \
 	acpi.o \
 	numa.o \
-	libccompat.o \
 	nemo.o \
 	pmc.o \
 	setjmp.o \
@@ -42,6 +41,7 @@ obj-y += \
         loader.o \
         shell.o \
 	fprintk.o \
+libccompat.o \
 
 obj-$(NAUT_CONFIG_PROFILE) += instrument.o
 obj-$(NAUT_CONFIG_XEON_PHI) += sfi.o
diff --git a/src/nautilus/fs.c b/src/nautilus/fs.c
index ac5e42b..fbc621e 100644
--- a/src/nautilus/fs.c
+++ b/src/nautilus/fs.c
@@ -1,18 +1,18 @@
-/* 
+/*
  * This file is part of the Nautilus AeroKernel developed
- * by the Hobbes and V3VEE Projects with funding from the 
- * United States National  Science Foundation and the Department of Energy.  
+ * by the Hobbes and V3VEE Projects with funding from the
+ * United States National  Science Foundation and the Department of Energy.
  *
  * The V3VEE Project is a joint project between Northwestern University
  * and the University of New Mexico.  The Hobbes Project is a collaboration
- * led by Sandia National Laboratories that includes several national 
+ * led by Sandia National Laboratories that includes several national
  * laboratories and universities. You can find out more at:
  * http://www.v3vee.org  and
  * http://xtack.sandia.gov/hobbes
  *
  * Copyright (c) 2016, Brady Lee and David Williams
  * Copyright (c) 2016, Peter Dinda
- * Copyright (c) 2016, The V3VEE Project  <http://www.v3vee.org> 
+ * Copyright (c) 2016, The V3VEE Project  <http://www.v3vee.org>
  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
  * All rights reserved.
  *
@@ -31,6 +31,7 @@
 #define INFO(fmt, args...)  INFO_PRINT("fs: " fmt, ##args)
 #define DEBUG(fmt, args...) DEBUG_PRINT("fs: " fmt, ##args)
 #define ERROR(fmt, args...) ERROR_PRINT("fs: " fmt, ##args)
+#define WARN(fmt, args...) WARN_PRINT("fs: " fmt, ##args)
 
 #ifndef NAUT_CONFIG_DEBUG_FILESYSTEM
 #undef DEBUG
@@ -51,15 +52,15 @@
 //typedef enum {BLOCK,NET} nk_fs_media_t;
 
 struct nk_fs_open_file_state {
-    spinlock_t lock;
-
-    struct list_head file_node;
-    
-    struct nk_fs  *fs;
-    void          *file;
-    
-    size_t   position;
-    int      flags;
+  spinlock_t lock;
+
+  struct list_head file_node;
+
+  struct nk_fs  *fs;
+  void          *file;
+
+  size_t   position;
+  int      flags;
 };
 
 
@@ -67,16 +68,16 @@ static spinlock_t state_lock;
 static struct list_head fs_list;
 static struct list_head open_files;
 
-static void map_over_open_files(void (*callback)(nk_fs_fd_t)) 
+static void map_over_open_files(void (*callback)(nk_fs_fd_t))
 {
-    struct list_head *cur;
-    struct list_head *temp;
-    nk_fs_fd_t fd;
-    
-    list_for_each_safe(cur, temp, &open_files) {
-	fd = list_entry(cur,struct nk_fs_open_file_state, file_node);
-	callback(fd);
-    }
+  struct list_head *cur;
+  struct list_head *temp;
+  nk_fs_fd_t fd;
+
+  list_for_each_safe(cur, temp, &open_files) {
+    fd = list_entry(cur,struct nk_fs_open_file_state, file_node);
+    callback(fd);
+  }
 }
 
 
@@ -86,470 +87,479 @@ static ssize_t __seek(nk_fs_fd_t fd, size_t offset, int whence);
 
 //static void directory_list(char *path);
 
-static int path_stat(struct nk_fs *fs, char *path, struct nk_fs_stat *st) 
+static int path_stat(struct nk_fs *fs, char *path, struct nk_fs_stat *st)
 {
-    if (fs && fs->interface && fs->interface->stat_path) {
-	return fs->interface->stat_path(fs->state, path, st);
-    } else {
-	return -1;
-    }
+  if (fs && fs->interface && fs->interface->stat_path) {
+    return fs->interface->stat_path(fs->state, path, st);
+  } else {
+    return -1;
+  }
 }
 
 
-static int file_stat(struct nk_fs *fs, void *file, struct nk_fs_stat *st) 
+static int file_stat(struct nk_fs *fs, void *file, struct nk_fs_stat *st)
 {
-    if (fs && fs->interface && fs->interface->stat) {
-	return fs->interface->stat(fs->state, file, st);
-    } else {
-	return -1;
-    }
+  if (fs && fs->interface && fs->interface->stat) {
+    return fs->interface->stat(fs->state, file, st);
+  } else {
+    return -1;
+  }
 }
 
 
-static void * file_open(struct nk_fs *fs, char *path, int access) 
+static void * file_open(struct nk_fs *fs, char *path, int access)
 {
-    if (fs && fs->interface && fs->interface->open_file) {
-	return fs->interface->open_file(fs->state, path);
-    } else {
-	return 0;
-    }
+  if (fs && fs->interface && fs->interface->open_file) {
+    return fs->interface->open_file(fs->state, path);
+  } else {
+    return 0;
+  }
 }
 
 
-static void *file_create(struct nk_fs *fs, char* path) 
+static void *file_create(struct nk_fs *fs, char* path)
 {
-    if (fs && fs->interface && fs->interface->create_file) {
-	return fs->interface->create_file(fs->state, path);
-    } else {
-	return 0;
-    }
+  if (fs && fs->interface && fs->interface->create_file) {
+    return fs->interface->create_file(fs->state, path);
+  } else {
+    return 0;
+  }
 }
 
 static int file_trunc(nk_fs_fd_t fd, off_t len)
 {
-    if (fd && fd->fs && fd->fs->interface && fd->fs->interface->trunc_file) {
-	return fd->fs->interface->trunc_file(fd->fs->state,fd->file,len);
-    } else {
-	return -1;
-    }
+  if (fd && fd->fs && fd->fs->interface && fd->fs->interface->trunc_file) {
+    return fd->fs->interface->trunc_file(fd->fs->state,fd->file,len);
+  } else {
+    return -1;
+  }
 }
 
-static inline ssize_t file_read(nk_fs_fd_t fd, char *buf, size_t num_bytes) 
+static inline ssize_t file_read(nk_fs_fd_t fd, char *buf, size_t num_bytes)
 {
-    if (!FS_FD_ERR(fd) && fd->fs && fd->fs->interface 
-	&& fd->fs->interface->read_file) {
-	return fd->fs->interface->read_file(fd->fs->state, 
-					    fd->file, 
-					    buf, 
-					    fd->position,
-					    num_bytes);
-    } else {
-	return -1;
-    }
+  if (!FS_FD_ERR(fd) && fd->fs && fd->fs->interface
+      && fd->fs->interface->read_file) {
+    return fd->fs->interface->read_file(fd->fs->state,
+                                        fd->file,
+                                        buf,
+                                        fd->position,
+                                        num_bytes);
+  } else {
+    return -1;
+  }
 }
 
-static inline ssize_t file_write(nk_fs_fd_t fd, char *buf, size_t num_bytes) 
+static inline ssize_t file_write(nk_fs_fd_t fd, char *buf, size_t num_bytes)
 {
-    if (!FS_FD_ERR(fd) && fd->fs && fd->fs->interface 
-	&& fd->fs->interface->write_file) {
-	return fd->fs->interface->write_file(fd->fs->state, 
-					     fd->file, 
-					     buf, 
-					     fd->position,
-					     num_bytes);
-    } else {
-	return -1;
-    }
+  if (!FS_FD_ERR(fd) && fd->fs && fd->fs->interface
+      && fd->fs->interface->write_file) {
+    return fd->fs->interface->write_file(fd->fs->state,
+                                         fd->file,
+                                         buf,
+                                         fd->position,
+                                         num_bytes);
+  } else {
+    return -1;
+  }
 }
 
 
-static int exists(struct nk_fs *fs, char *path) 
+static int exists(struct nk_fs *fs, char *path)
 {
-    //    DEBUG("Exists (%s, %s)\n",fs->name,path);
-    if (fs && fs->interface && fs->interface->exists) { 
-	return fs->interface->exists(fs->state, path);
-    } else {
-	return 0;
-    }
+  //    DEBUG("Exists (%s, %s)\n",fs->name,path);
+  if (fs && fs->interface && fs->interface->exists) {
+    return fs->interface->exists(fs->state, path);
+  } else {
+    return 0;
+  }
 }
 
-static int remove(struct nk_fs *fs, char* path) 
+static int remove(struct nk_fs *fs, char* path)
 {
-    if (fs && fs->interface && fs->interface->remove) { 
-	return fs->interface->remove(fs->state, path);
-    } else {
-	return -1;
-    }
+  if (fs && fs->interface && fs->interface->remove) {
+    return fs->interface->remove(fs->state, path);
+  } else {
+    return -1;
+  }
 }
 
-int nk_fs_init(void) 
+int nk_fs_init(void)
 {
-    INIT_LIST_HEAD(&fs_list);
-    INIT_LIST_HEAD(&open_files);
-    spinlock_init(&state_lock);
-    INFO("inited\n");
-    return 0;
+  INIT_LIST_HEAD(&fs_list);
+  INIT_LIST_HEAD(&open_files);
+  spinlock_init(&state_lock);
+
+#ifdef NAUT_CONFIG_NEWLIB
+
+  init_file_table();
+
+#endif // NAUT_CONFIG_NEWLIB
+
+  INFO("inited\n");
+  return 0;
 }
 
-int nk_deinit_fs(void) 
+int nk_deinit_fs(void)
 {
-    if (!list_empty(&open_files)) {
-	ERROR("Open files remain.. closing them\n");
-	map_over_open_files((void (*)(nk_fs_fd_t))nk_fs_close);
-    }
-    if (!list_empty(&fs_list)) {
-	ERROR("registered filesystems remain\n");
-    }
-    spinlock_deinit(&state_lock);
-    INFO("deinited\n");
-    return 0;
+  if (!list_empty(&open_files)) {
+    ERROR("Open files remain.. closing them\n");
+    map_over_open_files((void (*)(nk_fs_fd_t))nk_fs_close);
+  }
+  if (!list_empty(&fs_list)) {
+    ERROR("registered filesystems remain\n");
+  }
+
+  spinlock_deinit(&state_lock);
+  INFO("deinited\n");
+  return 0;
 }
 
 struct nk_fs *nk_fs_register(char *name, uint64_t flags, struct nk_fs_int *inter, void *state)
 {
-    STATE_LOCK_CONF;
-    struct nk_fs *f = malloc(sizeof(*f));
+  STATE_LOCK_CONF;
+  struct nk_fs *f = malloc(sizeof(*f));
 
-    DEBUG("register fs with name %s, flags 0x%lx, interface %p, and state %p\n", name, flags, inter, state);
+  DEBUG("register fs with name %s, flags 0x%lx, interface %p, and state %p\n", name, flags, inter, state);
 
-    if (!f) {
-	ERROR("Failed to allocate filesystem\n");
-	return 0;
-    }
-    
-    memset(f,0,sizeof(*f));
+  if (!f) {
+    ERROR("Failed to allocate filesystem\n");
+    return 0;
+  }
+
+  memset(f,0,sizeof(*f));
 
-    strncpy(f->name,name,FS_NAME_LEN); f->name[FS_NAME_LEN-1]=0;
-    strncpy(f->mount_path,"",MOUNT_PATH_LEN); f->mount_path[MOUNT_PATH_LEN-1]=0;
-    f->flags = flags;
-    f->interface = inter;
-    f->state = state;
+  strncpy(f->name,name,FS_NAME_LEN); f->name[FS_NAME_LEN-1]=0;
+  strncpy(f->mount_path,"",MOUNT_PATH_LEN); f->mount_path[MOUNT_PATH_LEN-1]=0;
+  f->flags = flags;
+  f->interface = inter;
+  f->state = state;
 
-    STATE_LOCK();
-    list_add(&f->fs_list_node,&fs_list);
-    STATE_UNLOCK();
-    
-    INFO("Added filesystem with name %s and flags 0x%lx\n", f->name,f->flags);
-    
-    return f;
+  STATE_LOCK();
+  list_add(&f->fs_list_node,&fs_list);
+  STATE_UNLOCK();
+
+  INFO("Added filesystem with name %s and flags 0x%lx\n", f->name,f->flags);
+
+  return f;
 }
 
 int            nk_fs_unregister(struct nk_fs *f)
 {
-    STATE_LOCK_CONF;
-    STATE_LOCK();
-    list_del(&f->fs_list_node);
-    STATE_UNLOCK();
-    INFO("Unregistered filesystem %s\n",f->name);
-    free(f);
-    return 0;
+  STATE_LOCK_CONF;
+  STATE_LOCK();
+  list_del(&f->fs_list_node);
+  STATE_UNLOCK();
+  INFO("Unregistered filesystem %s\n",f->name);
+  free(f);
+  return 0;
 }
 
 static struct nk_fs *__fs_find(char *name)
 {
-    struct list_head *cur;
-    struct nk_fs *target=0;
-    list_for_each(cur,&fs_list) {
-	if (!strncasecmp(list_entry(cur,struct nk_fs,fs_list_node)->name,name,FS_NAME_LEN)) { 
-	    target = list_entry(cur,struct nk_fs, fs_list_node);
-	    break;
-	}
+  struct list_head *cur;
+  struct nk_fs *target=0;
+  list_for_each(cur,&fs_list) {
+    if (!strncasecmp(list_entry(cur,struct nk_fs,fs_list_node)->name,name,FS_NAME_LEN)) {
+      target = list_entry(cur,struct nk_fs, fs_list_node);
+      break;
     }
-    return target;
+  }
+  return target;
 }
 
 struct nk_fs *nk_fs_find(char *name)
 {
-    STATE_LOCK_CONF;
-    struct nk_fs *fs=0;
-    STATE_LOCK();
-    fs = __fs_find(name);
-    STATE_UNLOCK();
-    return fs;
+  STATE_LOCK_CONF;
+  struct nk_fs *fs=0;
+  STATE_LOCK();
+  fs = __fs_find(name);
+  STATE_UNLOCK();
+  return fs;
 }
 
 static char *decode_path(char *path, char *fs_name)
 {
-    uint64_t n = strlen(path);
-    uint64_t i;
-
-    DEBUG("decode path %s\n",path);
-
-    for (i=0;(i<n) && (path[i]!=':');i++) {}
-
-    if (i>=n) {
-	// no devicename found, assume rootfs is meant
-	strcpy(fs_name,"rootfs");
-    } else {
-	// i=index of first ":", split name
-	strncpy(fs_name,path,i);
-	fs_name[i]=0;
-	path=path+i+1;
-    }
-    DEBUG("decoded as fs %s and path %s\n",fs_name, path);
-    return path;
+  uint64_t n = strlen(path);
+  uint64_t i;
+
+  DEBUG("decode path %s\n",path);
+
+  for (i=0;(i<n) && (path[i]!=':');i++) {}
+
+  if (i>=n) {
+    // no devicename found, assume rootfs is meant
+    strcpy(fs_name,"rootfs");
+  } else {
+    // i=index of first ":", split name
+    strncpy(fs_name,path,i);
+    fs_name[i]=0;
+    path=path+i+1;
+  }
+  DEBUG("decoded as fs %s and path %s\n",fs_name, path);
+  return path;
 }
 
 int nk_fs_stat(char *path, struct nk_fs_stat *st)
 {
-    STATE_LOCK_CONF;
-    struct nk_fs *fs;
-    char fs_name[strlen(path)+1];
+  STATE_LOCK_CONF;
+  struct nk_fs *fs;
+  char fs_name[strlen(path)+1];
 
-    path = decode_path(path,fs_name);
+  path = decode_path(path,fs_name);
 
-    DEBUG("decode has fs_name %s path %s\n", fs_name,path);
+  DEBUG("decode has fs_name %s path %s\n", fs_name,path);
 
-    STATE_LOCK();
-    fs = __fs_find(fs_name);
-    STATE_UNLOCK();
+  STATE_LOCK();
+  fs = __fs_find(fs_name);
+  STATE_UNLOCK();
 
-    if (!fs) { 
-	ERROR("Cannot find filesystem named %s\n",fs_name);
-	return -1;
-    }
+  if (!fs) {
+    ERROR("Cannot find filesystem named %s\n",fs_name);
+    return -1;
+  }
 
-    return path_stat(fs, path, st);
+  return path_stat(fs, path, st);
 }
 
 int nk_fs_truncate(char *path, off_t len)
 {
-    nk_fs_fd_t fd = nk_fs_open(path,O_RDWR,0);
-    
-    if (FS_FD_ERR(fd)) { 
-	return -1;
-    } else{
-	if (nk_fs_ftruncate(fd,len)) { 
-	    return -1;
-	} else {
-	    return nk_fs_close(fd);
-	}
+  nk_fs_fd_t fd = nk_fs_open(path,O_RDWR,0);
+
+  if (FS_FD_ERR(fd)) {
+    return -1;
+  } else{
+    if (nk_fs_ftruncate(fd,len)) {
+      return -1;
+    } else {
+      return nk_fs_close(fd);
     }
-}	
+  }
+}
 
-nk_fs_fd_t nk_fs_creat(char *path, int mode) 
+nk_fs_fd_t nk_fs_creat(char *path, int mode)
 {
-    return nk_fs_open(path,O_WRONLY|O_TRUNC|O_CREAT,0);
+  return nk_fs_open(path,O_WRONLY|O_TRUNC|O_CREAT,0);
 }
 
-nk_fs_fd_t nk_fs_open(char *path, int flags, int mode) 
+nk_fs_fd_t nk_fs_open(char *path, int flags, int mode)
 {
-    STATE_LOCK_CONF;
-    struct nk_fs *fs;
-    char fs_name[strlen(path)+1];
-
-    DEBUG("open path %s, flags=%d, mode=%d\n",path,flags,mode);
-
-    path=decode_path(path,fs_name);
-
-    STATE_LOCK();
-    fs = __fs_find(fs_name);
-    STATE_UNLOCK();
-
-    if (!fs) { 
-	ERROR("Cannot find filesystem named %s\n",fs_name);
-	return FS_BAD_FD;
-    }
-
-    nk_fs_fd_t fd = malloc(sizeof(*fd));
-    if (!fd) { 
-	ERROR("Can't allocate new open file entry\n");
-	return FS_BAD_FD;
+  STATE_LOCK_CONF;
+  struct nk_fs *fs;
+  char fs_name[strlen(path)+1];
+
+  DEBUG("open path %s, flags=%d, mode=%d\n",path,flags,mode);
+
+  path=decode_path(path,fs_name);
+
+  STATE_LOCK();
+  fs = __fs_find(fs_name);
+  STATE_UNLOCK();
+
+  if (!fs) {
+    ERROR("Cannot find filesystem named %s\n",fs_name);
+    return FS_BAD_FD;
+  }
+
+  nk_fs_fd_t fd = malloc(sizeof(*fd));
+  if (!fd) {
+    ERROR("Can't allocate new open file entry\n");
+    return FS_BAD_FD;
+  }
+
+  memset(fd,0,sizeof(*fd));
+  spinlock_init(&fd->lock);
+  fd->fs = fs;
+  fd->flags = flags;
+
+  if (exists(fs,path)) {
+    DEBUG("path %s exists\n", path);
+    fd->file = file_open(fs, path, flags);
+  } else if (flags & O_CREAT) {
+    DEBUG("path %s does not exist, but creating file\n",path);
+    if ((fs->flags & NK_FS_READONLY)) {
+      ERROR("Filesystem is not writeable so cannot create file\n");
+      return FS_BAD_FD;
     }
-
-    memset(fd,0,sizeof(*fd));
-    spinlock_init(&fd->lock);
-    fd->fs = fs;
-    fd->flags = flags;
-
-    if (exists(fs,path)) {
-	DEBUG("path %s exists\n", path);
-	fd->file = file_open(fs, path, flags);
-    } else if (flags & O_CREAT) {
-	DEBUG("path %s does not exist, but creating file\n",path);
-	if ((fs->flags & NK_FS_READONLY)) { 
-	    ERROR("Filesystem is not writeable so cannot create file\n");
-	    return FS_BAD_FD;
-	}
-	fd->file = file_create(fs, path);
-	if (!fd->file) {
-	    ERROR("Cannot create file %s\n", path);
-	    free(fd);
-	    return FS_BAD_FD;
-	} else {
-	    DEBUG("Created file %s on fs %s file=%p ", path, fs_name, fd);
-	} 
+    fd->file = file_create(fs, path);
+    if (!fd->file) {
+      ERROR("Cannot create file %s\n", path);
+      free(fd);
+      return FS_BAD_FD;
     } else {
-	DEBUG("path %s does not exist, and no creation requested\n",path);
-	free(fd);
-	return FS_BAD_FD;
+      DEBUG("Created file %s on fs %s file=%p ", path, fs_name, fd);
     }
-    
-    STATE_LOCK();
-    list_add(&fd->file_node, &open_files);
-    STATE_UNLOCK();
+  } else {
+    DEBUG("path %s does not exist, and no creation requested\n",path);
+    free(fd);
+    return FS_BAD_FD;
+  }
 
-    if (flags & O_TRUNC) { 
-	file_trunc(fd,0);
-    }
+  STATE_LOCK();
+  list_add(&fd->file_node, &open_files);
+  STATE_UNLOCK();
 
-    if (flags & O_APPEND) {
-	__seek(fd, 0, 2);
-    }
+  if (flags & O_TRUNC) {
+    file_trunc(fd,0);
+  }
+
+  if (flags & O_APPEND) {
+    __seek(fd, 0, 2);
+  }
 
-    DEBUG("Opened file %s on fs %s file=%p ", path, fs_name, fd);
+  DEBUG("Opened file %s on fs %s file=%p ", path, fs_name, fd);
 
-    return fd;
+  return fd;
 }
 
-int nk_fs_close(nk_fs_fd_t fd) 
+int nk_fs_close(nk_fs_fd_t fd)
 {
-    STATE_LOCK_CONF;
+  STATE_LOCK_CONF;
 
-    STATE_LOCK();
-    list_del(&fd->file_node);
-    STATE_UNLOCK();
+  STATE_LOCK();
+  list_del(&fd->file_node);
+  STATE_UNLOCK();
 
-    free(fd);
-    
-    return 0;
+  free(fd);
+
+  return 0;
 }
 
-ssize_t nk_fs_read(nk_fs_fd_t fd, void *buf, size_t num_bytes) 
+ssize_t nk_fs_read(nk_fs_fd_t fd, void *buf, size_t num_bytes)
 {
-    FILE_LOCK_CONF;
+  FILE_LOCK_CONF;
 
-    DEBUG("attempt read of %ld bytes starting at position %lu\n", num_bytes, fd->position);
+  DEBUG("attempt read of %ld bytes starting at position %lu\n", num_bytes, fd->position);
 
-    if (FS_FD_ERR(fd) || !(fd->flags & O_RDONLY)) { // includes RDWR
-	ERROR("Cannot read file not opened for reading\n");
-	return -1;
-    }
+  if (FS_FD_ERR(fd) || !(fd->flags & O_RDONLY)) { // includes RDWR
+    ERROR("Cannot read file not opened for reading\n");
+    return -1;
+  }
 
-    FILE_LOCK(fd);
-    ssize_t n = file_read(fd, buf, num_bytes);
-    if (n>=0) {fd->position += n; }
-    FILE_UNLOCK(fd);
+  FILE_LOCK(fd);
+  ssize_t n = file_read(fd, buf, num_bytes);
+  if (n>=0) {fd->position += n; }
+  FILE_UNLOCK(fd);
 
-    DEBUG("read %ld bytes ending at position %lu\n", n, fd->position);
+  DEBUG("read %ld bytes ending at position %lu\n", n, fd->position);
 
-    return n;
+  return n;
 }
 
-ssize_t nk_fs_write(nk_fs_fd_t fd, void *buf, size_t num_bytes) 
+ssize_t nk_fs_write(nk_fs_fd_t fd, void *buf, size_t num_bytes)
 {
-    FILE_LOCK_CONF;
+  FILE_LOCK_CONF;
 
-    DEBUG("attempt write of %ld bytes starting at position %lu\n", num_bytes, fd->position);
+  DEBUG("attempt write of %ld bytes starting at position %lu\n", num_bytes, fd->position);
 
-    if (FS_FD_ERR(fd) || !(fd->flags & O_WRONLY)) { // includes RDWR
-	ERROR("Cannot write file not opened for writing\n");
-	return -1;
-    }
+  if (FS_FD_ERR(fd) || !(fd->flags & O_WRONLY)) { // includes RDWR
+    ERROR("File descriptor that we couldn't open: %p flags: %lx\n",fd, FS_FD_ERR(fd) ? 0 : fd->flags);
+    ERROR("Cannot write file not opened for writing\n");
+    return -1;
+  }
 
-    if (fd->fs->flags & NK_FS_READONLY) { 
-	ERROR("Not a writeable filesystem\n");
-	return -1;
-    }
+  if (fd->fs->flags & NK_FS_READONLY) {
+    ERROR("Not a writeable filesystem\n");
+    return -1;
+  }
 
-    FILE_LOCK(fd);
-    ssize_t n = file_read(fd, buf, num_bytes);
-    if (n>=0) {fd->position += n; }
-    FILE_UNLOCK(fd);
+  FILE_LOCK(fd);
+  ssize_t n = file_read(fd, buf, num_bytes);
+  if (n>=0) {fd->position += n; }
+  FILE_UNLOCK(fd);
 
-    DEBUG("wrote %ld bytes ending at position %lu\n", n, fd->position);
+  DEBUG("wrote %ld bytes ending at position %lu\n", n, fd->position);
 
-    return n;
+  return n;
 }
 
 int nk_fs_ftruncate(nk_fs_fd_t fd, off_t len)
 {
-    FILE_LOCK_CONF;
-    int rc;
-
-    if (fd->fs->flags & NK_FS_READONLY) { 
-	ERROR("Filesystem is not writeable so cannot truncate file\n");
-	return -1;
-    }
-
-    FILE_LOCK(fd);
-    rc = file_trunc(fd,len);
-    FILE_UNLOCK(fd);
-    return rc;
+  FILE_LOCK_CONF;
+  int rc;
+
+  if (fd->fs->flags & NK_FS_READONLY) {
+    ERROR("Filesystem is not writeable so cannot truncate file\n");
+    return -1;
+  }
+
+  FILE_LOCK(fd);
+  rc = file_trunc(fd,len);
+  FILE_UNLOCK(fd);
+  return rc;
 }
 
 int nk_fs_fstat(nk_fs_fd_t fd, struct nk_fs_stat *st)
 {
-    return file_stat(fd->fs,fd->file,st);
+  return file_stat(fd->fs,fd->file,st);
 }
 
-static ssize_t __seek(nk_fs_fd_t fd, size_t offset, int whence) 
+static ssize_t __seek(nk_fs_fd_t fd, size_t offset, int whence)
 {
-    if (whence == 0) {
-	fd->position = offset;
-    } else if (whence == 1) {
-	fd->position += offset;
-    } else if (whence == 2) {
-	struct nk_fs_stat st;
-	
-	if (file_stat(fd->fs,fd->file,&st)) { 
-	    ERROR("Cannot stat file\n");
-	    return -1;
-	}
-	fd->position = st.st_size + offset;
-    }	else {
-	return -1;
+  if (whence == 0) {
+    fd->position = offset;
+  } else if (whence == 1) {
+    fd->position += offset;
+  } else if (whence == 2) {
+    struct nk_fs_stat st;
+
+    if (file_stat(fd->fs,fd->file,&st)) {
+      ERROR("Cannot stat file\n");
+      return -1;
     }
-    
-    return fd->position;
+    fd->position = st.st_size + offset;
+  }	else {
+    return -1;
+  }
+
+  return fd->position;
 }
- 
-off_t nk_fs_seek(nk_fs_fd_t fd, off_t offset, int whence) 
+
+off_t nk_fs_seek(nk_fs_fd_t fd, off_t offset, int whence)
 {
-    FILE_LOCK_CONF;
-    ssize_t s;
+  FILE_LOCK_CONF;
+  ssize_t s;
 
-    FILE_LOCK(fd);
-    s = __seek(fd, offset, whence);
-    FILE_UNLOCK(fd);
-    return s;
+  FILE_LOCK(fd);
+  s = __seek(fd, offset, whence);
+  FILE_UNLOCK(fd);
+  return s;
 }
 
 
 
-ssize_t nk_fs_tell(nk_fs_fd_t fd) 
+ssize_t nk_fs_tell(nk_fs_fd_t fd)
 {
-    return fd->position; 
+  return fd->position;
 }
 
 
 void nk_fs_dump_filesystems()
 {
-    STATE_LOCK_CONF;
-    struct list_head *cur;
+  STATE_LOCK_CONF;
+  struct list_head *cur;
 
-    STATE_LOCK();
+  STATE_LOCK();
 
-    list_for_each(cur,&fs_list) {
-	struct nk_fs *fs = list_entry(cur,struct nk_fs,fs_list_node);
-	nk_vc_printf("%s:\n", fs->name);
-    }
-    STATE_UNLOCK();
+  list_for_each(cur,&fs_list) {
+    struct nk_fs *fs = list_entry(cur,struct nk_fs,fs_list_node);
+    nk_vc_printf("%s:\n", fs->name);
+  }
+  STATE_UNLOCK();
 }
 
 
 void nk_fs_dump_files()
 {
-    STATE_LOCK_CONF;
-    struct list_head *cur;
+  STATE_LOCK_CONF;
+  struct list_head *cur;
 
-    STATE_LOCK();
+  STATE_LOCK();
 
-    list_for_each(cur,&open_files) {
-	struct nk_fs_open_file_state *f = list_entry(cur,struct nk_fs_open_file_state,file_node);
-	nk_vc_printf("%s:%p at %lu flags %x\n", f->fs->name,f->file,f->position,f->flags);
-    }
-    STATE_UNLOCK();
+  list_for_each(cur,&open_files) {
+    struct nk_fs_open_file_state *f = list_entry(cur,struct nk_fs_open_file_state,file_node);
+    nk_vc_printf("%s:%p at %lu flags %x\n", f->fs->name,f->file,f->position,f->flags);
+  }
+  STATE_UNLOCK();
 }
 
 
@@ -560,115 +570,115 @@ void nk_fs_dump_files()
 #if 0
 
 void test_fs() {
-	char *buf;
-	int fn;
-
-	/*
-		 DEBUG("Opening files...");
-		 fn = open("/readme", O_RDWR);
-		 fn = open("/null", O_RDWR);
-		 fn = open("/nothing", O_RDWR);
-		 fn = open("/nothing", O_RDWR);
-		 DEBUG("Done opening");
-		 DEBUG("Printing...");
-		 iterate_opened(file_print);
-		 DEBUG("Done printing");
-		 DEBUG("Closing files...");
-		 iterate_opened(__close);
-		 DEBUG("Done closing");
-		 DEBUG("");
-		 */
-
-	char path1[] = "/null";
-	buf = malloc(50);
-	fn = open(path1, O_RDWR);
-	/*DEBUG("Read %d", read(fn, buf, 15));
-		DEBUG("Text %s", buf);
-		DEBUG("Seeking %d", lseek(fn, 0, 0));
-		DEBUG("Write %d", write(fn, "jjjije\nifjeiffdfdfdfdfj", 15));
-		DEBUG("Seeking %d", lseek(fn, 0, 0));
-		DEBUG("Read %d", read(fn, buf, 15));
-		DEBUG("Text %s", buf);*/
-
-	DEBUG("********************************");
-	char* path2 = "/readme";
-	char* rd_buf = malloc(50);
-	char* wr_buf = malloc(50);
-	fn = open(path2, O_RDWR);
-	int result = read(fn, rd_buf, 50);
-	DEBUG("Read %d %s", result, rd_buf);
-	DEBUG("********************************");
-	path2 = "/a";
-	fn = open(path2, O_RDWR|O_CREAT);
-	wr_buf = "testing";
-	result = write(fn, wr_buf,7);
-	DEBUG("Write %d", result);
-	lseek(fn,0,0);
-	result = read(fn, rd_buf, 7);
-	DEBUG("Read %d %s", result, rd_buf);
-	DEBUG("********************************");
-	ext2_remove_file(&RAMFS_START,path2);
-	fn = open(path2, O_RDWR|O_CREAT);
-	//lseek(fn, 10,0);
-	wr_buf = "testing";
-	//result = write(fn, wr_buf,1);
-	//DEBUG("Write %d", result);
-	//lseek(fn,0,0);
-	rd_buf = malloc(50);
-	result = read(fn, rd_buf, 7);
-	DEBUG("Read %d %s", result, rd_buf);
-	DEBUG("********************************");
-	free(buf);
-	/*
-		 char path2[] = "/a";
-		 DEBUG("FILE CREATE TEST");
-		 DEBUG("Creating file %d", create_file(path2));
-		 fn = open(path2, O_RDWR);
-		 DEBUG("Wrote %d", write(fn, "Testing file /a", 15));
-		 DEBUG("Seeking %d", lseek(fn, 0, 0));
-		 DEBUG("Read %d", read(fn, buf, 15));
-		 DEBUG("Read %s", buf);
-	//int inum = get_inode_by_path(&RAMFS_START, path);
-	//DEBUG("Inode %d", inum); 
-	//DEBUG("Size %d", ext2_get_size(&RAMFS_START, inum)); 
-	//DEBUG("Done creating");
-	//DEBUG("");
-	free(buf);
-	*/
-
-	/*
-		 DEBUG("FILE REMOVE TEST");
-		 DEBUG("%d", get_block_size(&RAMFS_START));
-		 uint32_t rootnum = get_inode_by_path(&RAMFS_START, "/");
-		 DEBUG("Root inode %d", rootnum);
-		 fn = open("/", 1);
-		 size_t rootsize = 1024;
-		 buf = malloc(1024);
-		 DEBUG("Read %d", read(fn, buf, rootsize));
-		 path = "/readme";
-		 DEBUG("Removing file %d", ext2_remove_file(&RAMFS_START, path));
-		 DEBUG("Removing file %d", ext2_remove_file(&RAMFS_START, path));
-		 */
-
-
-	/*
-		 printk("-----------------------------------\n");
-		 fn = file_open("/large_test_file3", O_RDWR);
-		 fn = file_open("/large_test_file4", O_RDWR);
-		 fn = file_open("/large_test_file", O_RDWR);
-		 file_seek(fn,get_block_size(deviceRAMFS_START)*12,0);
-		 char* read_buf = malloc(get_block_size(deviceRAMFS_START)*12);
-		 char* write_buf = "****Testing****";
-		 int result = file_write(fn,write_buf, strlen(write_buf));
-		 printk("Write1: \n%d\n", result);
-		 file_seek(fn,get_block_size(deviceRAMFS_START)*11,0);
-		 result = file_read(fn,read_buf,get_block_size(deviceRAMFS_START)*2);
-		 printk("Read1: \n%s \n%d\n",read_buf, result);
-		 printk("\nGet: %d\n", get_inode_by_path(&RAMFS_START, "/test1"));
-		 */
-
-	run_all();
-	DEBUG("Done");
+  char *buf;
+  int fn;
+
+  /*
+    DEBUG("Opening files...");
+    fn = open("/readme", O_RDWR);
+    fn = open("/null", O_RDWR);
+    fn = open("/nothing", O_RDWR);
+    fn = open("/nothing", O_RDWR);
+    DEBUG("Done opening");
+    DEBUG("Printing...");
+    iterate_opened(file_print);
+    DEBUG("Done printing");
+    DEBUG("Closing files...");
+    iterate_opened(__close);
+    DEBUG("Done closing");
+    DEBUG("");
+  */
+
+  char path1[] = "/null";
+  buf = malloc(50);
+  fn = open(path1, O_RDWR);
+  /*DEBUG("Read %d", read(fn, buf, 15));
+    DEBUG("Text %s", buf);
+    DEBUG("Seeking %d", lseek(fn, 0, 0));
+    DEBUG("Write %d", write(fn, "jjjije\nifjeiffdfdfdfdfj", 15));
+    DEBUG("Seeking %d", lseek(fn, 0, 0));
+    DEBUG("Read %d", read(fn, buf, 15));
+    DEBUG("Text %s", buf);*/
+
+  DEBUG("********************************");
+  char* path2 = "/readme";
+  char* rd_buf = malloc(50);
+  char* wr_buf = malloc(50);
+  fn = open(path2, O_RDWR);
+  int result = read(fn, rd_buf, 50);
+  DEBUG("Read %d %s", result, rd_buf);
+  DEBUG("********************************");
+  path2 = "/a";
+  fn = open(path2, O_RDWR|O_CREAT);
+  wr_buf = "testing";
+  result = write(fn, wr_buf,7);
+  DEBUG("Write %d", result);
+  lseek(fn,0,0);
+  result = read(fn, rd_buf, 7);
+  DEBUG("Read %d %s", result, rd_buf);
+  DEBUG("********************************");
+  ext2_remove_file(&RAMFS_START,path2);
+  fn = open(path2, O_RDWR|O_CREAT);
+  //lseek(fn, 10,0);
+  wr_buf = "testing";
+  //result = write(fn, wr_buf,1);
+  //DEBUG("Write %d", result);
+  //lseek(fn,0,0);
+  rd_buf = malloc(50);
+  result = read(fn, rd_buf, 7);
+  DEBUG("Read %d %s", result, rd_buf);
+  DEBUG("********************************");
+  free(buf);
+  /*
+    char path2[] = "/a";
+    DEBUG("FILE CREATE TEST");
+    DEBUG("Creating file %d", create_file(path2));
+    fn = open(path2, O_RDWR);
+    DEBUG("Wrote %d", write(fn, "Testing file /a", 15));
+    DEBUG("Seeking %d", lseek(fn, 0, 0));
+    DEBUG("Read %d", read(fn, buf, 15));
+    DEBUG("Read %s", buf);
+    //int inum = get_inode_by_path(&RAMFS_START, path);
+    //DEBUG("Inode %d", inum);
+    //DEBUG("Size %d", ext2_get_size(&RAMFS_START, inum));
+    //DEBUG("Done creating");
+    //DEBUG("");
+    free(buf);
+  */
+
+  /*
+    DEBUG("FILE REMOVE TEST");
+    DEBUG("%d", get_block_size(&RAMFS_START));
+    uint32_t rootnum = get_inode_by_path(&RAMFS_START, "/");
+    DEBUG("Root inode %d", rootnum);
+    fn = open("/", 1);
+    size_t rootsize = 1024;
+    buf = malloc(1024);
+    DEBUG("Read %d", read(fn, buf, rootsize));
+    path = "/readme";
+    DEBUG("Removing file %d", ext2_remove_file(&RAMFS_START, path));
+    DEBUG("Removing file %d", ext2_remove_file(&RAMFS_START, path));
+  */
+
+
+  /*
+    printk("-----------------------------------\n");
+    fn = file_open("/large_test_file3", O_RDWR);
+    fn = file_open("/large_test_file4", O_RDWR);
+    fn = file_open("/large_test_file", O_RDWR);
+    file_seek(fn,get_block_size(deviceRAMFS_START)*12,0);
+    char* read_buf = malloc(get_block_size(deviceRAMFS_START)*12);
+    char* write_buf = "****Testing****";
+    int result = file_write(fn,write_buf, strlen(write_buf));
+    printk("Write1: \n%d\n", result);
+    file_seek(fn,get_block_size(deviceRAMFS_START)*11,0);
+    result = file_read(fn,read_buf,get_block_size(deviceRAMFS_START)*2);
+    printk("Read1: \n%s \n%d\n",read_buf, result);
+    printk("\nGet: %d\n", get_inode_by_path(&RAMFS_START, "/test1"));
+  */
+
+  run_all();
+  DEBUG("Done");
 }
 
 #endif
diff --git a/src/nautilus/libccompat.c b/src/nautilus/libccompat.c
index 4fbb4dc..31e01f4 100644
--- a/src/nautilus/libccompat.c
+++ b/src/nautilus/libccompat.c
@@ -27,6 +27,12 @@
  * 
  *
  */
+
+// If including the newlib libc, this is all unnecessary
+// and result in multiple definition errors
+
+#ifndef NAUT_CONFIG_NEWLIB
+
 #include <nautilus/nautilus.h>
 #include <nautilus/libccompat.h>
 #include <nautilus/thread.h>
@@ -287,7 +293,7 @@ fprintf (FILE * f, const char * s, ...)
 #endif
 }
 
-int 
+int
 printf (const char * s, ...)
 {
 #if 0
@@ -518,3 +524,5 @@ GEN_DEF(strxfrm)
 GEN_DEF(wcsxfrm)
 GEN_DEF(__kernel_standard);
 GEN_DEF(__get_cpu_features);
+
+#endif  // NAUT_CONFIG_NEWLIB
diff --git a/src/nautilus/naut_string.c b/src/nautilus/naut_string.c
index e7615eb..4e50898 100644
--- a/src/nautilus/naut_string.c
+++ b/src/nautilus/naut_string.c
@@ -52,7 +52,12 @@ _L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,       /* 224-239 */
 _L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L};      /* 240-255 */
 
 
+extern long simple_strtol(const char*, char**, unsigned int);
+
+#ifndef NAUT_CONFIG_NEWLIB
+
 #ifdef NAUT_CONFIG_USE_NAUT_BUILTINS
+
 size_t 
 strlen (const char * str)
 {
@@ -405,25 +410,78 @@ atoi (const char * buf)
     return ret;
 }
 
+long 
+strtol (const char * str, char ** endptr, int base)
+{
+  return simple_strtol(str, endptr, base);
+}
 
-int 
-strtoi (const char * nptr, char ** endptr) 
+size_t
+strspn (const char * s, const char * accept) 
 {
-    int ret = 0;
-    char * buf = (char *)nptr;
+    int match = 1;
+    int cnt = 0;
+    int i = 0;
+    int accept_len = strlen(accept);
 
-    while ((*buf >= '0') && (*buf <= '9')) {
-    ret *= 10;
-    ret += (*buf - '0');
+    while (match) {
+    match = 0;
 
-    buf++;
+    for (i = 0; i < accept_len; i++) {
+        if (s[cnt] == accept[i]) {
+        match = 1;
+        cnt++;
+        break;
+        }
+    }
+    }
 
-    if (endptr) {
-        *endptr = buf;
+    return cnt;
+}
+
+
+size_t 
+strcspn (const char * s, const char * reject) 
+{
+    int match = 0;
+    int cnt = 0;
+    int i = 0;
+    int reject_len = strlen(reject);
+
+    while (!match) {
+    for (i = 0; i < reject_len; i++) {
+        if (s[cnt] == reject[i]) {
+        match = 1;
+        break;
+        }
     }
+
+    if (!match) {
+        cnt++;
     }
 
-    return ret;
+    }
+
+    return cnt;
+}
+
+
+char *
+strstr (const char * s1, const char * s2)
+{
+        int l1, l2;
+
+        l2 = strlen(s2);
+        if (!l2)
+                return (char *)s1;
+        l1 = strlen(s1);
+        while (l1 >= l2) {
+                l1--;
+                if (!memcmp(s1, s2, l2))
+                        return (char *)s1;
+                s1++;
+        }
+        return NULL;
 }
 
 long int
@@ -437,9 +495,33 @@ extern long simple_strtol(const char*, char**, unsigned int);
 long 
 strtol (const char * str, char ** endptr, int base)
 {
-    return simple_strtol(str, endptr, base);
+  return simple_strtol(str, endptr, base);
+}
+
+#endif  // ndef NAUT_CONFIG_NEWLIB
+
+int 
+strtoi (const char * nptr, char ** endptr) 
+{
+    int ret = 0;
+    char * buf = (char *)nptr;
+
+    while ((*buf >= '0') && (*buf <= '9')) {
+    ret *= 10;
+    ret += (*buf - '0');
+
+    buf++;
+
+    if (endptr) {
+        *endptr = buf;
+    }
+    }
+
+    return ret;
 }
 
+
+
 uint64_t 
 atox (const char * buf) {
     uint64_t ret = 0;
@@ -494,75 +576,6 @@ strtox (const char * nptr, char ** endptr)
 }
 
 
-size_t 
-strspn (const char * s, const char * accept) 
-{
-    int match = 1;
-    int cnt = 0;
-    int i = 0;
-    int accept_len = strlen(accept);
-
-    while (match) {
-    match = 0;
-
-    for (i = 0; i < accept_len; i++) {
-        if (s[cnt] == accept[i]) {
-        match = 1;
-        cnt++;
-        break;
-        }
-    }
-    }
-
-    return cnt;
-}
-
-
-size_t 
-strcspn (const char * s, const char * reject) 
-{
-    int match = 0;
-    int cnt = 0;
-    int i = 0;
-    int reject_len = strlen(reject);
-
-    while (!match) {
-    for (i = 0; i < reject_len; i++) {
-        if (s[cnt] == reject[i]) {
-        match = 1;
-        break;
-        }
-    }
-
-    if (!match) {
-        cnt++;
-    }
-
-    }
-
-    return cnt;
-}
-
-
-char *
-strstr (const char * s1, const char * s2)
-{
-        int l1, l2;
-
-        l2 = strlen(s2);
-        if (!l2)
-                return (char *)s1;
-        l1 = strlen(s1);
-        while (l1 >= l2) {
-                l1--;
-                if (!memcmp(s1, s2, l2))
-                        return (char *)s1;
-                s1++;
-        }
-        return NULL;
-}
-
-
 void 
 str_tolower (char * s) 
 {
diff --git a/src/nautilus/printk.c b/src/nautilus/printk.c
index 07040e8..be790e4 100644
--- a/src/nautilus/printk.c
+++ b/src/nautilus/printk.c
@@ -58,1552 +58,1557 @@ struct printk_state {
 	unsigned int index;
 };
 
-
-static void
-flush (struct printk_state *state)
+#ifndef NAUT_CONFIG_NEWLIB
+/**
+ * vsnprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * This function follows C99 vsnprintf, but has some extensions:
+ * %pS output the name of a text symbol with offset
+ * %ps output the name of a text symbol without offset
+ * %pF output the name of a function pointer with its offset
+ * %pf output the name of a function pointer without its offset
+ * %pR output the address range in a struct resource
+ * %n is ignored
+ *
+ * The return value is the number of characters which would
+ * be generated for the given input, excluding the trailing
+ * '\0', as per ISO C99. If you want to have the exact
+ * number of characters written into @buf as return value
+ * (not including the trailing '\0'), use vscnprintf(). If the
+ * return is greater than or equal to @size, the resulting
+ * string is truncated.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want snprintf() instead.
+ */
+int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
 {
-	int i;
-
-	for (i = 0; i < state->index; i++) {
-	  do_putchar(state->buf[i]);
-	}
-
-	state->index = 0;
-}
+	unsigned long long num;
+	char *str, *end, c;
+	int read;
+	struct printf_spec spec = {0};
 
+	/* Reject out-of-range values early.  Large positive sizes are
+	   used for unknown buffer sizes. */
+	if (WARN_ON_ONCE((int) size < 0))
+		return 0;
 
-static void
-printk_char (char * arg, int c)
-{
-	struct printk_state *state = (struct printk_state *) arg;
+	str = buf;
+	end = buf + size;
 
-	if (c == '\n')
-	{
-		state->buf[state->index] = 0;
-		do_puts(state->buf);
-		state->index = 0;
-	}
-	else if ((c == 0) || (state->index >= PRINTK_BUFMAX))
-	{
-		flush(state);
-		do_putchar(c);
-	}
-	else
-	{
-		state->buf[state->index] = c;
-		state->index++;
+	/* Make sure end is always >= buf */
+	if (end < buf) {
+		end = ((void *)-1);
+		size = end - buf;
 	}
-}
 
+	while (*fmt) {
+		const char *old_fmt = fmt;
 
-int 
-vprintk (const char * fmt, va_list args)
-{
-	struct printk_state state;
+		read = format_decode(fmt, &spec);
 
-    //uint8_t flags = spin_lock_irq_save(&printk_lock);
+		fmt += read;
 
-	state.index = 0;
-	_doprnt(fmt, args, 0, printk_char, (char *) &state);
+		switch (spec.type) {
+		case FORMAT_TYPE_NONE: {
+			int copy = read;
+			if (str < end) {
+				if (copy > end - str)
+					copy = end - str;
+				memcpy(str, old_fmt, copy);
+			}
+			str += read;
+			break;
+		}
 
-	if (state.index != 0)
-	    flush(&state);
+		case FORMAT_TYPE_WIDTH:
+			spec.field_width = va_arg(args, int);
+			break;
 
-    //spin_unlock_irq_restore(&printk_lock, flags);
-	/* _doprnt currently doesn't pass back error codes,
-	   so just assume nothing bad happened.  */
-	return 0;
-}
+		case FORMAT_TYPE_PRECISION:
+			spec.precision = va_arg(args, int);
+			break;
 
+		case FORMAT_TYPE_CHAR:
+			if (!(spec.flags & LEFT)) {
+				while (--spec.field_width > 0) {
+					if (str < end)
+						*str = ' ';
+					++str;
 
-void 
-panic (const char * fmt, ...)
-{
-    va_list arg;
+				}
+			}
+			c = (unsigned char) va_arg(args, int);
+			if (str < end)
+				*str = c;
+			++str;
+			while (--spec.field_width > 0) {
+				if (str < end)
+					*str = ' ';
+				++str;
+			}
+			break;
 
-    va_start(arg, fmt);
-    vprintk(fmt, arg);
-    va_end(arg);
+		case FORMAT_TYPE_STR:
+			str = string(str, end, va_arg(args, char *), spec);
+			break;
 
-   __asm__ __volatile__ ("cli");
-   while(1);
-}
+		case FORMAT_TYPE_PTR:
+			str = pointer(fmt+1, str, end, va_arg(args, void *),
+				      spec);
+			while (isalnum(*fmt))
+				fmt++;
+			break;
 
+		case FORMAT_TYPE_PERCENT_CHAR:
+			if (str < end)
+				*str = '%';
+			++str;
+			break;
 
+		case FORMAT_TYPE_INVALID:
+			if (str < end)
+				*str = '%';
+			++str;
+			break;
 
-int
-early_printk (const char *fmt, va_list args)
-{
-    return vprintk(fmt, args);
-}
+		case FORMAT_TYPE_NRCHARS: {
+			int qualifier = spec.qualifier;
 
+			if (qualifier == 'l') {
+				long *ip = va_arg(args, long *);
+				*ip = (str - buf);
+			} else if (qualifier == 'Z' ||
+					qualifier == 'z') {
+				size_t *ip = va_arg(args, size_t *);
+				*ip = (str - buf);
+			} else {
+				int *ip = va_arg(args, int *);
+				*ip = (str - buf);
+			}
+			break;
+		}
 
-int
-printk (const char *fmt, ...)
-{
-	va_list	args;
-	int err = 0;
+		default:
+			switch (spec.type) {
+			case FORMAT_TYPE_LONG_LONG:
+				num = va_arg(args, long long);
+				break;
+			case FORMAT_TYPE_ULONG:
+				num = va_arg(args, unsigned long);
+				break;
+			case FORMAT_TYPE_LONG:
+				num = va_arg(args, long);
+				break;
+			case FORMAT_TYPE_SIZE_T:
+				num = va_arg(args, size_t);
+				break;
+			case FORMAT_TYPE_PTRDIFF:
+				num = va_arg(args, ptrdiff_t);
+				break;
+			case FORMAT_TYPE_UBYTE:
+				num = (unsigned char) va_arg(args, int);
+				break;
+			case FORMAT_TYPE_BYTE:
+				num = (signed char) va_arg(args, int);
+				break;
+			case FORMAT_TYPE_USHORT:
+				num = (unsigned short) va_arg(args, int);
+				break;
+			case FORMAT_TYPE_SHORT:
+				num = (short) va_arg(args, int);
+				break;
+			case FORMAT_TYPE_INT:
+				num = (int) va_arg(args, int);
+				break;
+			default:
+				num = va_arg(args, unsigned int);
+			}
 
-	va_start(args, fmt);
-	err = vprintk(fmt, args);
-	va_end(args);
+			str = number(str, end, num, spec);
+		}
+	}
 
-	return err;
-}
+	if (size > 0) {
+		if (str < end)
+			*str = '\0';
+		else
+			end[-1] = '\0';
+	}
 
-const char hex_asc[] = "0123456789abcdef";
+	/* the trailing null byte doesn't count towards the total */
+	return str-buf;
 
-#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
-#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]
+}
 
-static inline char *pack_hex_byte(char *buf, uint8_t byte)
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * The function returns the number of characters written
+ * into @buf. Use vsnprintf() or vscnprintf() in order to avoid
+ * buffer overflows.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf() instead.
+ *
+ * See the vsnprintf() documentation for format string extensions over C99.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args)
 {
-        *buf++ = hex_asc_hi(byte);
-        *buf++ = hex_asc_lo(byte);
-        return buf;
-}
-
-/* Works only for digits and letters, but small and fast */
-#define TOLOWER(x) ((x) | 0x20)
-
-static unsigned int simple_guess_base(const char *cp)
-{
-	if (cp[0] == '0') {
-		if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
-			return 16;
-		else
-			return 8;
-	} else {
-		return 10;
-	}
+	return vsnprintf(buf, INT_MAX, fmt, args);
 }
 
 /**
- * simple_strtoul - convert a string to an unsigned long
- * @cp: The start of the string
- * @endp: A pointer to the end of the parsed string will be placed here
- * @base: The number base to use
+ * sprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ *
+ * The function returns the number of characters written
+ * into @buf. Use snprintf() or scnprintf() in order to avoid
+ * buffer overflows.
+ *
+ * See the vsnprintf() documentation for format string extensions over C99.
  */
-unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)
+int sprintf(char * buf, const char *fmt, ...)
 {
-	unsigned long result = 0;
-
-	if (!base)
-		base = simple_guess_base(cp);
-
-	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
-		cp += 2;
-
-	while (isxdigit(*cp)) {
-		unsigned int value;
-
-		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
-		if (value >= base)
-			break;
-		result = result * base + value;
-		cp++;
-	}
+	va_list args;
+	int i;
 
-	if (endp)
-		*endp = (char *)cp;
-	return result;
+	va_start(args, fmt);
+	i=vsnprintf(buf, INT_MAX, fmt, args);
+	va_end(args);
+	return i;
 }
 
 /**
- * simple_strtol - convert a string to a signed long
- * @cp: The start of the string
- * @endp: A pointer to the end of the parsed string will be placed here
- * @base: The number base to use
+ * snprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ *
+ * The return value is the number of characters which would be
+ * generated for the given input, excluding the trailing null,
+ * as per ISO C99.  If the return is greater than or equal to
+ * @size, the resulting string is truncated.
+ *
+ * See the vsnprintf() documentation for format string extensions over C99.
  */
-long simple_strtol(const char *cp, char **endp, unsigned int base)
+int snprintf(char * buf, size_t size, const char *fmt, ...)
 {
-	if(*cp == '-')
-		return -simple_strtoul(cp + 1, endp, base);
-	return simple_strtoul(cp, endp, base);
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i=vsnprintf(buf,size,fmt,args);
+	va_end(args);
+	return i;
 }
 
+
 /**
- * simple_strtoull - convert a string to an unsigned long long
- * @cp: The start of the string
- * @endp: A pointer to the end of the parsed string will be placed here
- * @base: The number base to use
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:	input buffer
+ * @fmt:	format of buffer
+ * @args:	arguments
  */
-unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
+int vsscanf(const char * buf, const char * fmt, va_list args)
 {
-	unsigned long long result = 0;
-
-	if (!base)
-		base = simple_guess_base(cp);
+	const char *str = buf;
+	char *next;
+	char digit;
+	int num = 0;
+	int qualifier;
+	int base;
+	int field_width;
+	int is_sign = 0;
 
-	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
-		cp += 2;
+	while(*fmt && *str) {
+		/* skip any white space in format */
+		/* white space in format matchs any amount of
+		 * white space, including none, in the input.
+		 */
+		if (isspace(*fmt)) {
+			while (isspace(*fmt))
+				++fmt;
+			while (isspace(*str))
+				++str;
+		}
 
-	while (isxdigit(*cp)) {
-		unsigned int value;
+		/* anything that is not a conversion must match exactly */
+		if (*fmt != '%' && *fmt) {
+			if (*fmt++ != *str++)
+				break;
+			continue;
+		}
 
-		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
-		if (value >= base)
+		if (!*fmt)
 			break;
-		result = result * base + value;
-		cp++;
-	}
-
-	if (endp)
-		*endp = (char *)cp;
-	return result;
-}
-
-/**
- * simple_strtoll - convert a string to a signed long long
- * @cp: The start of the string
- * @endp: A pointer to the end of the parsed string will be placed here
- * @base: The number base to use
- */
-long long simple_strtoll(const char *cp, char **endp, unsigned int base)
-{
-	if(*cp=='-')
-		return -simple_strtoull(cp + 1, endp, base);
-	return simple_strtoull(cp, endp, base);
-}
+		++fmt;
+		
+		/* skip this conversion.
+		 * advance both strings to next white space
+		 */
+		if (*fmt == '*') {
+			while (!isspace(*fmt) && *fmt != '%' && *fmt)
+				fmt++;
+			while (!isspace(*str) && *str)
+				str++;
+			continue;
+		}
 
-/**
- * strict_strtoul - convert a string to an unsigned long strictly
- * @cp: The string to be converted
- * @base: The number base to use
- * @res: The converted result value
- *
- * strict_strtoul converts a string to an unsigned long only if the
- * string is really an unsigned long string, any string containing
- * any invalid char at the tail will be rejected and -EINVAL is returned,
- * only a newline char at the tail is acceptible because people generally
- * change a module parameter in the following way:
- *
- * 	echo 1024 > /sys/module/e1000/parameters/copybreak
- *
- * echo will append a newline to the tail.
- *
- * It returns 0 if conversion is successful and *res is set to the converted
- * value, otherwise it returns -EINVAL and *res is set to 0.
- *
- * simple_strtoul just ignores the successive invalid characters and
- * return the converted value of prefix part of the string.
- */
-int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
-{
-	char *tail;
-	unsigned long val;
-	size_t len;
+		/* get field width */
+		field_width = -1;
+		if (isdigit(*fmt))
+			field_width = skip_atoi(&fmt);
 
-	*res = 0;
-	len = strlen(cp);
-	if (len == 0)
-		return -EINVAL;
+		/* get conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
+		    *fmt == 'Z' || *fmt == 'z') {
+			qualifier = *fmt++;
+			if (unlikely(qualifier == *fmt)) {
+				if (qualifier == 'h') {
+					qualifier = 'H';
+					fmt++;
+				} else if (qualifier == 'l') {
+					qualifier = 'L';
+					fmt++;
+				}
+			}
+		}
+		base = 10;
+		is_sign = 0;
 
-	val = simple_strtoul(cp, &tail, base);
-	if (tail == cp)
-		return -EINVAL;
-	if ((*tail == '\0') ||
-		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
-		*res = val;
-		return 0;
-	}
+		if (!*fmt || !*str)
+			break;
 
-	return -EINVAL;
-}
+		switch(*fmt++) {
+		case 'c':
+		{
+			char *s = (char *) va_arg(args,char*);
+			if (field_width == -1)
+				field_width = 1;
+			do {
+				*s++ = *str++;
+			} while (--field_width > 0 && *str);
+			num++;
+		}
+		continue;
+		case 's':
+		{
+			char *s = (char *) va_arg(args, char *);
+			if(field_width == -1)
+				field_width = INT_MAX;
+			/* first, skip leading white space in buffer */
+			while (isspace(*str))
+				str++;
 
-/**
- * strict_strtol - convert a string to a long strictly
- * @cp: The string to be converted
- * @base: The number base to use
- * @res: The converted result value
- *
- * strict_strtol is similiar to strict_strtoul, but it allows the first
- * character of a string is '-'.
- *
- * It returns 0 if conversion is successful and *res is set to the converted
- * value, otherwise it returns -EINVAL and *res is set to 0.
- */
-int strict_strtol(const char *cp, unsigned int base, long *res)
-{
-	int ret;
-	if (*cp == '-') {
-		ret = strict_strtoul(cp + 1, base, (unsigned long *)res);
-		if (!ret)
-			*res = -(*res);
-	} else {
-		ret = strict_strtoul(cp, base, (unsigned long *)res);
+			/* now copy until next white space */
+			while (*str && !isspace(*str) && field_width--) {
+				*s++ = *str++;
+			}
+			*s = '\0';
+			num++;
+		}
+		continue;
+		case 'n':
+			/* return number of characters read so far */
+		{
+			int *i = (int *)va_arg(args,int*);
+			*i = str - buf;
+		}
+		continue;
+		case 'o':
+			base = 8;
+			break;
+		case 'x':
+		case 'X':
+			base = 16;
+			break;
+		case 'i':
+                        base = 0;
+		case 'd':
+			is_sign = 1;
+		case 'u':
+			break;
+		case '%':
+			/* looking for '%' in str */
+			if (*str++ != '%') 
+				return num;
+			continue;
+		default:
+			/* invalid format; stop here */
+			return num;
+		}
+
+		/* have some sort of integer conversion.
+		 * first, skip white space in buffer.
+		 */
+		while (isspace(*str))
+			str++;
+
+		digit = *str;
+		if (is_sign && digit == '-')
+			digit = *(str + 1);
+
+		if (!digit
+                    || (base == 16 && !isxdigit(digit))
+                    || (base == 10 && !isdigit(digit))
+                    || (base == 8 && (!isdigit(digit) || digit > '7'))
+                    || (base == 0 && !isdigit(digit)))
+				break;
+
+		switch(qualifier) {
+		case 'H':	/* that's 'hh' in format */
+			if (is_sign) {
+				signed char *s = (signed char *) va_arg(args,signed char *);
+				*s = (signed char) simple_strtol(str,&next,base);
+			} else {
+				unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
+				*s = (unsigned char) simple_strtoul(str, &next, base);
+			}
+			break;
+		case 'h':
+			if (is_sign) {
+				short *s = (short *) va_arg(args,short *);
+				*s = (short) simple_strtol(str,&next,base);
+			} else {
+				unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
+				*s = (unsigned short) simple_strtoul(str, &next, base);
+			}
+			break;
+		case 'l':
+			if (is_sign) {
+				long *l = (long *) va_arg(args,long *);
+				*l = simple_strtol(str,&next,base);
+			} else {
+				unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
+				*l = simple_strtoul(str,&next,base);
+			}
+			break;
+		case 'L':
+			if (is_sign) {
+				long long *l = (long long*) va_arg(args,long long *);
+				*l = simple_strtoll(str,&next,base);
+			} else {
+				unsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);
+				*l = simple_strtoull(str,&next,base);
+			}
+			break;
+		case 'Z':
+		case 'z':
+		{
+			size_t *s = (size_t*) va_arg(args,size_t*);
+			*s = (size_t) simple_strtoul(str,&next,base);
+		}
+		break;
+		default:
+			if (is_sign) {
+				int *i = (int *) va_arg(args, int*);
+				*i = (int) simple_strtol(str,&next,base);
+			} else {
+				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
+				*i = (unsigned int) simple_strtoul(str,&next,base);
+			}
+			break;
+		}
+		num++;
+
+		if (!next)
+			break;
+		str = next;
 	}
 
-	return ret;
+	/*
+	 * Now we've come all the way through so either the input string or the
+	 * format ended. In the former case, there can be a %n at the current
+	 * position in the format that needs to be filled.
+	 */
+	if (*fmt == '%' && *(fmt + 1) == 'n') {
+		int *p = (int *)va_arg(args, int *);
+		*p = str - buf;
+	}
+
+	return num;
 }
 
 /**
- * strict_strtoull - convert a string to an unsigned long long strictly
- * @cp: The string to be converted
- * @base: The number base to use
- * @res: The converted result value
- *
- * strict_strtoull converts a string to an unsigned long long only if the
- * string is really an unsigned long long string, any string containing
- * any invalid char at the tail will be rejected and -EINVAL is returned,
- * only a newline char at the tail is acceptible because people generally
- * change a module parameter in the following way:
- *
- * 	echo 1024 > /sys/module/e1000/parameters/copybreak
- *
- * echo will append a newline to the tail of the string.
- *
- * It returns 0 if conversion is successful and *res is set to the converted
- * value, otherwise it returns -EINVAL and *res is set to 0.
- *
- * simple_strtoull just ignores the successive invalid characters and
- * return the converted value of prefix part of the string.
+ * sscanf - Unformat a buffer into a list of arguments
+ * @buf:	input buffer
+ * @fmt:	formatting of buffer
+ * @...:	resulting arguments
  */
-int strict_strtoull(const char *cp, unsigned int base, unsigned long long *res)
+int sscanf(const char * buf, const char * fmt, ...)
 {
-	char *tail;
-	unsigned long long val;
-	size_t len;
+	va_list args;
+	int i;
 
-	*res = 0;
-	len = strlen(cp);
-	if (len == 0)
-		return -EINVAL;
+	va_start(args,fmt);
+	i = vsscanf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
 
-	val = simple_strtoull(cp, &tail, base);
-	if (tail == cp)
-		return -EINVAL;
-	if ((*tail == '\0') ||
-		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
-		*res = val;
-		return 0;
-	}
 
-	return -EINVAL;
-}
+#endif
 
-/**
- * strict_strtoll - convert a string to a long long strictly
- * @cp: The string to be converted
- * @base: The number base to use
- * @res: The converted result value
- *
- * strict_strtoll is similiar to strict_strtoull, but it allows the first
- * character of a string is '-'.
- *
- * It returns 0 if conversion is successful and *res is set to the converted
- * value, otherwise it returns -EINVAL and *res is set to 0.
- */
-int strict_strtoll(const char *cp, unsigned int base, long long *res)
+static void
+flush (struct printk_state *state)
 {
-	int ret;
-	if (*cp == '-') {
-		ret = strict_strtoull(cp + 1, base, (unsigned long long *)res);
-		if (!ret)
-			*res = -(*res);
-	} else {
-		ret = strict_strtoull(cp, base, (unsigned long long *)res);
+	int i;
+
+	for (i = 0; i < state->index; i++) {
+	  do_putchar(state->buf[i]);
 	}
 
-	return ret;
+	state->index = 0;
 }
 
-static int skip_atoi(const char **s)
+
+static void
+printk_char (char * arg, int c)
 {
-	int i=0;
+	struct printk_state *state = (struct printk_state *) arg;
 
-	while (isdigit(**s))
-		i = i*10 + *((*s)++) - '0';
-	return i;
+	if (c == '\n')
+	{
+		state->buf[state->index] = 0;
+		do_puts(state->buf);
+		state->index = 0;
+	}
+	else if ((c == 0) || (state->index >= PRINTK_BUFMAX))
+	{
+		flush(state);
+		do_putchar(c);
+	}
+	else
+	{
+		state->buf[state->index] = c;
+		state->index++;
+	}
 }
 
-/* Decimal conversion is by far the most typical, and is used
- * for /proc and /sys data. This directly impacts e.g. top performance
- * with many processes running. We optimize it for speed
- * using code from
- * http://www.cs.uiowa.edu/~jones/bcd/decimal.html
- * (with permission from the author, Douglas W. Jones). */
 
-/* Formats correctly any integer in [0,99999].
- * Outputs from one to five digits depending on input.
- * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
-static char* put_dec_trunc(char *buf, unsigned q)
+int 
+vprintk (const char * fmt, va_list args)
 {
-	unsigned d3, d2, d1, d0;
-	d1 = (q>>4) & 0xf;
-	d2 = (q>>8) & 0xf;
-	d3 = (q>>12);
+	struct printk_state state;
 
-	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
-	q = (d0 * 0xcd) >> 11;
-	d0 = d0 - 10*q;
-	*buf++ = d0 + '0'; /* least significant digit */
-	d1 = q + 9*d3 + 5*d2 + d1;
-	if (d1 != 0) {
-		q = (d1 * 0xcd) >> 11;
-		d1 = d1 - 10*q;
-		*buf++ = d1 + '0'; /* next digit */
+    //uint8_t flags = spin_lock_irq_save(&printk_lock);
 
-		d2 = q + 2*d2;
-		if ((d2 != 0) || (d3 != 0)) {
-			q = (d2 * 0xd) >> 7;
-			d2 = d2 - 10*q;
-			*buf++ = d2 + '0'; /* next digit */
+	state.index = 0;
+	_doprnt(fmt, args, 0, printk_char, (char *) &state);
 
-			d3 = q + 4*d3;
-			if (d3 != 0) {
-				q = (d3 * 0xcd) >> 11;
-				d3 = d3 - 10*q;
-				*buf++ = d3 + '0';  /* next digit */
-				if (q != 0)
-					*buf++ = q + '0';  /* most sign. digit */
-			}
-		}
-	}
-	return buf;
+	if (state.index != 0)
+	    flush(&state);
+
+    //spin_unlock_irq_restore(&printk_lock, flags);
+	/* _doprnt currently doesn't pass back error codes,
+	   so just assume nothing bad happened.  */
+	return 0;
 }
-/* Same with if's removed. Always emits five digits */
-static char* put_dec_full(char *buf, unsigned q)
-{
-	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
-	/* but anyway, gcc produces better code with full-sized ints */
-	unsigned d3, d2, d1, d0;
-	d1 = (q>>4) & 0xf;
-	d2 = (q>>8) & 0xf;
-	d3 = (q>>12);
 
-	/* Possible ways to approx. divide by 10 */
-	/* gcc -O2 replaces multiply with shifts and adds */
-	// (x * 0xcd) >> 11: 11001101 - shorter code than * 0x67 (on i386)
-	// (x * 0x67) >> 10:  1100111
-	// (x * 0x34) >> 9:    110100 - same
-	// (x * 0x1a) >> 8:     11010 - same
-	// (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
 
-	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
-	q = (d0 * 0xcd) >> 11;
-	d0 = d0 - 10*q;
-	*buf++ = d0 + '0';
-	d1 = q + 9*d3 + 5*d2 + d1;
-		q = (d1 * 0xcd) >> 11;
-		d1 = d1 - 10*q;
-		*buf++ = d1 + '0';
+void 
+panic (const char * fmt, ...)
+{
+    va_list arg;
 
-		d2 = q + 2*d2;
-			q = (d2 * 0xd) >> 7;
-			d2 = d2 - 10*q;
-			*buf++ = d2 + '0';
+    va_start(arg, fmt);
+    vprintk(fmt, arg);
+    va_end(arg);
 
-			d3 = q + 4*d3;
-				q = (d3 * 0xcd) >> 11; /* - shorter code */
-				/* q = (d3 * 0x67) >> 10; - would also work */
-				d3 = d3 - 10*q;
-				*buf++ = d3 + '0';
-					*buf++ = q + '0';
-	return buf;
+   __asm__ __volatile__ ("cli");
+   while(1);
 }
-/* No inlining helps gcc to use registers better */
-static __noinline char* put_dec(char *buf, unsigned long long num)
+
+
+
+int
+early_printk (const char *fmt, va_list args)
 {
-	while (1) {
-		unsigned rem;
-		if (num < 100000)
-			return put_dec_trunc(buf, num);
-		rem = (unsigned) (num % 100000);
-		num = num / 100000;
-		buf = put_dec_full(buf, rem);
-	}
+    return vprintk(fmt, args);
 }
 
-#define ZEROPAD	1		/* pad with zero */
-#define SIGN	2		/* unsigned/signed long */
-#define PLUS	4		/* show plus */
-#define SPACE	8		/* space if plus */
-#define LEFT	16		/* left justified */
-#define SMALL	32		/* Must be 32 == 0x20 */
-#define SPECIAL	64		/* 0x */
 
-enum format_type {
-	FORMAT_TYPE_NONE, /* Just a string part */
-	FORMAT_TYPE_WIDTH,
-	FORMAT_TYPE_PRECISION,
-	FORMAT_TYPE_CHAR,
-	FORMAT_TYPE_STR,
-	FORMAT_TYPE_PTR,
-	FORMAT_TYPE_PERCENT_CHAR,
-	FORMAT_TYPE_INVALID,
-	FORMAT_TYPE_LONG_LONG,
-	FORMAT_TYPE_ULONG,
-	FORMAT_TYPE_LONG,
-	FORMAT_TYPE_UBYTE,
-	FORMAT_TYPE_BYTE,
-	FORMAT_TYPE_USHORT,
-	FORMAT_TYPE_SHORT,
-	FORMAT_TYPE_UINT,
-	FORMAT_TYPE_INT,
-	FORMAT_TYPE_NRCHARS,
-	FORMAT_TYPE_SIZE_T,
-	FORMAT_TYPE_PTRDIFF
-};
+int
+printk (const char *fmt, ...)
+{
+	va_list	args;
+	int err = 0;
 
-struct printf_spec {
-	enum format_type	type;
-	int			flags;		/* flags to number() */
-	int			field_width;	/* width of output field */
-	int			base;
-	int			precision;	/* # of digits/chars */
-	int			qualifier;
-};
+	va_start(args, fmt);
+	err = vprintk(fmt, args);
+	va_end(args);
 
-static char *number(char *buf, char *end, unsigned long long num,
-			struct printf_spec spec)
+	return err;
+}
+
+const char hex_asc[] = "0123456789abcdef";
+
+#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
+#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]
+
+static inline char *pack_hex_byte(char *buf, uint8_t byte)
 {
-	/* we are called with base 8, 10 or 16, only, thus don't need "G..."  */
-	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */
+        *buf++ = hex_asc_hi(byte);
+        *buf++ = hex_asc_lo(byte);
+        return buf;
+}
 
-	char tmp[66];
-	char sign;
-	char locase;
-	int need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);
-	int i;
+/* Works only for digits and letters, but small and fast */
+#define TOLOWER(x) ((x) | 0x20)
 
-	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
-	 * produces same digits or (maybe lowercased) letters */
-	locase = (spec.flags & SMALL);
-	if (spec.flags & LEFT)
-		spec.flags &= ~ZEROPAD;
-	sign = 0;
-	if (spec.flags & SIGN) {
-		if ((signed long long) num < 0) {
-			sign = '-';
-			num = - (signed long long) num;
-			spec.field_width--;
-		} else if (spec.flags & PLUS) {
-			sign = '+';
-			spec.field_width--;
-		} else if (spec.flags & SPACE) {
-			sign = ' ';
-			spec.field_width--;
-		}
-	}
-	if (need_pfx) {
-		spec.field_width--;
-		if (spec.base == 16)
-			spec.field_width--;
+static unsigned int simple_guess_base(const char *cp)
+{
+	if (cp[0] == '0') {
+		if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
+			return 16;
+		else
+			return 8;
+	} else {
+		return 10;
 	}
+}
 
-	/* generate full string in tmp[], in reverse order */
-	i = 0;
-	if (num == 0)
-		tmp[i++] = '0';
-	/* Generic code, for any base:
-	else do {
-		tmp[i++] = (digits[do_div(num,base)] | locase);
-	} while (num != 0);
-	*/
-	else if (spec.base != 10) { /* 8 or 16 */
-		int mask = spec.base - 1;
-		int shift = 3;
-		if (spec.base == 16) shift = 4;
-		do {
-			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
-			num >>= shift;
-		} while (num);
-	} else { /* base 10 */
-		i = put_dec(tmp, num) - tmp;
-	}
+/**
+ * simple_strtoul - convert a string to an unsigned long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long result = 0;
 
-	/* printing 100 using %2d gives "100", not "00" */
-	if (i > spec.precision)
-		spec.precision = i;
-	/* leading space padding */
-	spec.field_width -= spec.precision;
-	if (!(spec.flags & (ZEROPAD+LEFT))) {
-		while(--spec.field_width >= 0) {
-			if (buf < end)
-				*buf = ' ';
-			++buf;
-		}
+	if (!base)
+		base = simple_guess_base(cp);
+
+	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
+		cp += 2;
+
+	while (isxdigit(*cp)) {
+		unsigned int value;
+
+		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
+		if (value >= base)
+			break;
+		result = result * base + value;
+		cp++;
 	}
-	/* sign */
-	if (sign) {
-		if (buf < end)
-			*buf = sign;
-		++buf;
-	}
-	/* "0x" / "0" prefix */
-	if (need_pfx) {
-		if (buf < end)
-			*buf = '0';
-		++buf;
-		if (spec.base == 16) {
-			if (buf < end)
-				*buf = ('X' | locase);
-			++buf;
-		}
-	}
-	/* zero or space padding */
-	if (!(spec.flags & LEFT)) {
-		char c = (spec.flags & ZEROPAD) ? '0' : ' ';
-		while (--spec.field_width >= 0) {
-			if (buf < end)
-				*buf = c;
-			++buf;
-		}
-	}
-	/* hmm even more zero padding? */
-	while (i <= --spec.precision) {
-		if (buf < end)
-			*buf = '0';
-		++buf;
-	}
-	/* actual digits of result */
-	while (--i >= 0) {
-		if (buf < end)
-			*buf = tmp[i];
-		++buf;
-	}
-	/* trailing space padding */
-	while (--spec.field_width >= 0) {
-		if (buf < end)
-			*buf = ' ';
-		++buf;
-	}
-	return buf;
-}
-
-static char *string(char *buf, char *end, char *s, struct printf_spec spec)
-{
-	int len, i;
-
-	if ((unsigned long)s < PAGE_SIZE_4KB)
-		s = "<NULL>";
 
-	len = strnlen(s, spec.precision);
-
-	if (!(spec.flags & LEFT)) {
-		while (len < spec.field_width--) {
-			if (buf < end)
-				*buf = ' ';
-			++buf;
-		}
-	}
-	for (i = 0; i < len; ++i) {
-		if (buf < end)
-			*buf = *s;
-		++buf; ++s;
-	}
-	while (len < spec.field_width--) {
-		if (buf < end)
-			*buf = ' ';
-		++buf;
-	}
-	return buf;
+	if (endp)
+		*endp = (char *)cp;
+	return result;
 }
 
-static char *symbol_string(char *buf, char *end, void *ptr,
-				struct printf_spec spec, char ext)
+/**
+ * simple_strtol - convert a string to a signed long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long simple_strtol(const char *cp, char **endp, unsigned int base)
 {
-	unsigned long value = (unsigned long) ptr;
-#ifdef CONFIG_KALLSYMS
-	char sym[KSYM_SYMBOL_LEN];
-	if (ext != 'f' && ext != 's')
-		kallsyms_sprint_symbol(sym, value);
-	else
-		kallsyms_lookup(value, NULL, NULL, sym);
-	return string(buf, end, sym, spec);
-#else
-	spec.field_width = 2*sizeof(void *);
-	spec.flags |= SPECIAL | SMALL | ZEROPAD;
-	spec.base = 16;
-	return number(buf, end, value, spec);
-#endif
+	if(*cp == '-')
+		return -simple_strtoul(cp + 1, endp, base);
+	return simple_strtoul(cp, endp, base);
 }
 
-
-static char *mac_address_string(char *buf, char *end, uint8_t *addr,
-				struct printf_spec spec, const char *fmt)
+/**
+ * simple_strtoull - convert a string to an unsigned long long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)
 {
-	char mac_addr[sizeof("xx:xx:xx:xx:xx:xx")];
-	char *p = mac_addr;
-	int i;
+	unsigned long long result = 0;
 
-	for (i = 0; i < 6; i++) {
-		p = pack_hex_byte(p, addr[i]);
-		if (fmt[0] == 'M' && i != 5)
-			*p++ = ':';
-	}
-	*p = '\0';
+	if (!base)
+		base = simple_guess_base(cp);
 
-	return string(buf, end, mac_addr, spec);
-}
+	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
+		cp += 2;
 
-static char *ip4_string(char *p, const uint8_t *addr, bool_t leading_zeros)
-{
-	int i;
+	while (isxdigit(*cp)) {
+		unsigned int value;
 
-	for (i = 0; i < 4; i++) {
-		char temp[3];	/* hold each IP quad in reverse order */
-		int digits = put_dec_trunc(temp, addr[i]) - temp;
-		if (leading_zeros) {
-			if (digits < 3)
-				*p++ = '0';
-			if (digits < 2)
-				*p++ = '0';
-		}
-		/* reverse the digits in the quad */
-		while (digits--)
-			*p++ = temp[digits];
-		if (i < 3)
-			*p++ = '.';
+		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
+		if (value >= base)
+			break;
+		result = result * base + value;
+		cp++;
 	}
 
-	*p = '\0';
-	return p;
+	if (endp)
+		*endp = (char *)cp;
+	return result;
 }
 
-static char *ip6_string(char *p, const char *addr, const char *fmt)
+/**
+ * simple_strtoll - convert a string to a signed long long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long simple_strtoll(const char *cp, char **endp, unsigned int base)
 {
-	int i;
-	for (i = 0; i < 8; i++) {
-		p = pack_hex_byte(p, *addr++);
-		p = pack_hex_byte(p, *addr++);
-		if (fmt[0] == 'I' && i != 7)
-			*p++ = ':';
-	}
-
-	*p = '\0';
-	return p;
+	if(*cp=='-')
+		return -simple_strtoull(cp + 1, endp, base);
+	return simple_strtoull(cp, endp, base);
 }
 
-static char *ip6_addr_string(char *buf, char *end, const uint8_t *addr,
-			     struct printf_spec spec, const char *fmt)
+/**
+ * strict_strtoul - convert a string to an unsigned long strictly
+ * @cp: The string to be converted
+ * @base: The number base to use
+ * @res: The converted result value
+ *
+ * strict_strtoul converts a string to an unsigned long only if the
+ * string is really an unsigned long string, any string containing
+ * any invalid char at the tail will be rejected and -EINVAL is returned,
+ * only a newline char at the tail is acceptible because people generally
+ * change a module parameter in the following way:
+ *
+ * 	echo 1024 > /sys/module/e1000/parameters/copybreak
+ *
+ * echo will append a newline to the tail.
+ *
+ * It returns 0 if conversion is successful and *res is set to the converted
+ * value, otherwise it returns -EINVAL and *res is set to 0.
+ *
+ * simple_strtoul just ignores the successive invalid characters and
+ * return the converted value of prefix part of the string.
+ */
+int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
 {
-	char ip6_addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")];
+	char *tail;
+	unsigned long val;
+	size_t len;
 
-	ip6_string(ip6_addr, addr, fmt);
+	*res = 0;
+	len = strlen(cp);
+	if (len == 0)
+		return -EINVAL;
 
-	return string(buf, end, ip6_addr, spec);
+	val = simple_strtoul(cp, &tail, base);
+	if (tail == cp)
+		return -EINVAL;
+	if ((*tail == '\0') ||
+		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
+		*res = val;
+		return 0;
+	}
+
+	return -EINVAL;
 }
 
-static char *ip4_addr_string(char *buf, char *end, const uint8_t *addr,
-			     struct printf_spec spec, const char *fmt)
+/**
+ * strict_strtol - convert a string to a long strictly
+ * @cp: The string to be converted
+ * @base: The number base to use
+ * @res: The converted result value
+ *
+ * strict_strtol is similiar to strict_strtoul, but it allows the first
+ * character of a string is '-'.
+ *
+ * It returns 0 if conversion is successful and *res is set to the converted
+ * value, otherwise it returns -EINVAL and *res is set to 0.
+ */
+int strict_strtol(const char *cp, unsigned int base, long *res)
 {
-	char ip4_addr[sizeof("255.255.255.255")];
-
-	ip4_string(ip4_addr, addr, fmt[0] == 'i');
+	int ret;
+	if (*cp == '-') {
+		ret = strict_strtoul(cp + 1, base, (unsigned long *)res);
+		if (!ret)
+			*res = -(*res);
+	} else {
+		ret = strict_strtoul(cp, base, (unsigned long *)res);
+	}
 
-	return string(buf, end, ip4_addr, spec);
+	return ret;
 }
 
-/*
- * Show a '%p' thing.  A kernel extension is that the '%p' is followed
- * by an extra set of alphanumeric characters that are extended format
- * specifiers.
- *
- * Right now we handle:
+/**
+ * strict_strtoull - convert a string to an unsigned long long strictly
+ * @cp: The string to be converted
+ * @base: The number base to use
+ * @res: The converted result value
  *
- * - 'F' For symbolic function descriptor pointers with offset
- * - 'f' For simple symbolic function names without offset
- * - 'S' For symbolic direct pointers with offset
- * - 's' For symbolic direct pointers without offset
- * - 'M' For a 6-byte MAC address, it prints the address in the
- *       usual colon-separated hex notation
- * - 'm' For a 6-byte MAC address, it prints the hex address without colons
- * - 'I' [46] for IPv4/IPv6 addresses printed in the usual way
- *       IPv4 uses dot-separated decimal without leading 0's (1.2.3.4)
- *       IPv6 uses colon separated network-order 16 bit hex with leading 0's
- * - 'i' [46] for 'raw' IPv4/IPv6 addresses
- *       IPv6 omits the colons (01020304...0f)
- *       IPv4 uses dot-separated decimal with leading 0's (010.123.045.006)
- * - 'I6c' for IPv6 addresses printed as specified by
- *       http://www.ietf.org/id/draft-kawamura-ipv6-text-representation-03.txt
- * Note: The difference between 'S' and 'F' is that on ia64 and ppc64
- * function pointers are really function descriptors, which contain a
- * pointer to the real address.
+ * strict_strtoull converts a string to an unsigned long long only if the
+ * string is really an unsigned long long string, any string containing
+ * any invalid char at the tail will be rejected and -EINVAL is returned,
+ * only a newline char at the tail is acceptible because people generally
+ * change a module parameter in the following way:
+ *
+ * 	echo 1024 > /sys/module/e1000/parameters/copybreak
+ *
+ * echo will append a newline to the tail of the string.
+ *
+ * It returns 0 if conversion is successful and *res is set to the converted
+ * value, otherwise it returns -EINVAL and *res is set to 0.
+ *
+ * simple_strtoull just ignores the successive invalid characters and
+ * return the converted value of prefix part of the string.
  */
-static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
-			struct printf_spec spec)
+int strict_strtoull(const char *cp, unsigned int base, unsigned long long *res)
 {
-	if (!ptr)
-		return string(buf, end, "(null)", spec);
+	char *tail;
+	unsigned long long val;
+	size_t len;
 
-	switch (*fmt) {
-	case 's':
-		/* Fallthrough */
-	case 'S':
-		return symbol_string(buf, end, ptr, spec, *fmt);
-	case 'M':			/* Colon separated: 00:01:02:03:04:05 */
-	case 'm':			/* Contiguous: 000102030405 */
-		return mac_address_string(buf, end, ptr, spec, fmt);
-	case 'I':			/* Formatted IP supported
-					 * 4:	1.2.3.4
-					 * 6:	0001:0203:...:0708
-					 * 6c:	1::708 or 1::1.2.3.4
-					 */
-	case 'i':			/* Contiguous:
-					 * 4:	001.002.003.004
-					 * 6:   000102...0f
-					 */
-		switch (fmt[1]) {
-		case '6':
-			return ip6_addr_string(buf, end, ptr, spec, fmt);
-		case '4':
-			return ip4_addr_string(buf, end, ptr, spec, fmt);
-		}
-		break;
-	}
-	spec.flags |= SMALL;
-	if (spec.field_width == -1) {
-		spec.field_width = 2*sizeof(void *);
-		spec.flags |= ZEROPAD;
+	*res = 0;
+	len = strlen(cp);
+	if (len == 0)
+		return -EINVAL;
+
+	val = simple_strtoull(cp, &tail, base);
+	if (tail == cp)
+		return -EINVAL;
+	if ((*tail == '\0') ||
+		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
+		*res = val;
+		return 0;
 	}
-	spec.base = 16;
 
-	return number(buf, end, (unsigned long) ptr, spec);
+	return -EINVAL;
 }
 
-/*
- * Helper function to decode printf style format.
- * Each call decode a token from the format and return the
- * number of characters read (or likely the delta where it wants
- * to go on the next call).
- * The decoded token is returned through the parameters
+/**
+ * strict_strtoll - convert a string to a long long strictly
+ * @cp: The string to be converted
+ * @base: The number base to use
+ * @res: The converted result value
  *
- * 'h', 'l', or 'L' for integer fields
- * 'z' support added 23/7/1999 S.H.
- * 'z' changed to 'Z' --davidm 1/25/99
- * 't' added for ptrdiff_t
+ * strict_strtoll is similiar to strict_strtoull, but it allows the first
+ * character of a string is '-'.
  *
- * @fmt: the format string
- * @type of the token returned
- * @flags: various flags such as +, -, # tokens..
- * @field_width: overwritten width
- * @base: base of the number (octal, hex, ...)
- * @precision: precision of a number
- * @qualifier: qualifier of a number (long, size_t, ...)
+ * It returns 0 if conversion is successful and *res is set to the converted
+ * value, otherwise it returns -EINVAL and *res is set to 0.
  */
-static int format_decode(const char *fmt, struct printf_spec *spec)
+int strict_strtoll(const char *cp, unsigned int base, long long *res)
 {
-	const char *start = fmt;
-
-	/* we finished early by reading the field width */
-	if (spec->type == FORMAT_TYPE_WIDTH) {
-		if (spec->field_width < 0) {
-			spec->field_width = -spec->field_width;
-			spec->flags |= LEFT;
-		}
-		spec->type = FORMAT_TYPE_NONE;
-		goto precision;
+	int ret;
+	if (*cp == '-') {
+		ret = strict_strtoull(cp + 1, base, (unsigned long long *)res);
+		if (!ret)
+			*res = -(*res);
+	} else {
+		ret = strict_strtoull(cp, base, (unsigned long long *)res);
 	}
 
-	/* we finished early by reading the precision */
-	if (spec->type == FORMAT_TYPE_PRECISION) {
-		if (spec->precision < 0)
-			spec->precision = 0;
-
-		spec->type = FORMAT_TYPE_NONE;
-		goto qualifier;
-	}
+	return ret;
+}
 
-	/* By default */
-	spec->type = FORMAT_TYPE_NONE;
+static int skip_atoi(const char **s)
+{
+	int i=0;
 
-	for (; *fmt ; ++fmt) {
-		if (*fmt == '%')
-			break;
-	}
+	while (isdigit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
 
-	/* Return the current non-format string */
-	if (fmt != start || !*fmt)
-		return fmt - start;
+/* Decimal conversion is by far the most typical, and is used
+ * for /proc and /sys data. This directly impacts e.g. top performance
+ * with many processes running. We optimize it for speed
+ * using code from
+ * http://www.cs.uiowa.edu/~jones/bcd/decimal.html
+ * (with permission from the author, Douglas W. Jones). */
 
-	/* Process flags */
-	spec->flags = 0;
+/* Formats correctly any integer in [0,99999].
+ * Outputs from one to five digits depending on input.
+ * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
+static char* put_dec_trunc(char *buf, unsigned q)
+{
+	unsigned d3, d2, d1, d0;
+	d1 = (q>>4) & 0xf;
+	d2 = (q>>8) & 0xf;
+	d3 = (q>>12);
 
-	while (1) { /* this also skips first '%' */
-		bool_t found = true;
+	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
+	q = (d0 * 0xcd) >> 11;
+	d0 = d0 - 10*q;
+	*buf++ = d0 + '0'; /* least significant digit */
+	d1 = q + 9*d3 + 5*d2 + d1;
+	if (d1 != 0) {
+		q = (d1 * 0xcd) >> 11;
+		d1 = d1 - 10*q;
+		*buf++ = d1 + '0'; /* next digit */
 
-		++fmt;
+		d2 = q + 2*d2;
+		if ((d2 != 0) || (d3 != 0)) {
+			q = (d2 * 0xd) >> 7;
+			d2 = d2 - 10*q;
+			*buf++ = d2 + '0'; /* next digit */
 
-		switch (*fmt) {
-		case '-': spec->flags |= LEFT;    break;
-		case '+': spec->flags |= PLUS;    break;
-		case ' ': spec->flags |= SPACE;   break;
-		case '#': spec->flags |= SPECIAL; break;
-		case '0': spec->flags |= ZEROPAD; break;
-		default:  found = false;
+			d3 = q + 4*d3;
+			if (d3 != 0) {
+				q = (d3 * 0xcd) >> 11;
+				d3 = d3 - 10*q;
+				*buf++ = d3 + '0';  /* next digit */
+				if (q != 0)
+					*buf++ = q + '0';  /* most sign. digit */
+			}
 		}
-
-		if (!found)
-			break;
 	}
+	return buf;
+}
+/* Same with if's removed. Always emits five digits */
+static char* put_dec_full(char *buf, unsigned q)
+{
+	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
+	/* but anyway, gcc produces better code with full-sized ints */
+	unsigned d3, d2, d1, d0;
+	d1 = (q>>4) & 0xf;
+	d2 = (q>>8) & 0xf;
+	d3 = (q>>12);
 
-	/* get field width */
-	spec->field_width = -1;
+	/* Possible ways to approx. divide by 10 */
+	/* gcc -O2 replaces multiply with shifts and adds */
+	// (x * 0xcd) >> 11: 11001101 - shorter code than * 0x67 (on i386)
+	// (x * 0x67) >> 10:  1100111
+	// (x * 0x34) >> 9:    110100 - same
+	// (x * 0x1a) >> 8:     11010 - same
+	// (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
 
-	if (isdigit(*fmt))
-		spec->field_width = skip_atoi(&fmt);
-	else if (*fmt == '*') {
-		/* it's the next argument */
-		spec->type = FORMAT_TYPE_WIDTH;
-		return ++fmt - start;
-	}
+	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
+	q = (d0 * 0xcd) >> 11;
+	d0 = d0 - 10*q;
+	*buf++ = d0 + '0';
+	d1 = q + 9*d3 + 5*d2 + d1;
+		q = (d1 * 0xcd) >> 11;
+		d1 = d1 - 10*q;
+		*buf++ = d1 + '0';
 
-precision:
-	/* get the precision */
-	spec->precision = -1;
-	if (*fmt == '.') {
-		++fmt;
-		if (isdigit(*fmt)) {
-			spec->precision = skip_atoi(&fmt);
-			if (spec->precision < 0)
-				spec->precision = 0;
-		} else if (*fmt == '*') {
-			/* it's the next argument */
-			spec->type = FORMAT_TYPE_PRECISION;
-			return ++fmt - start;
-		}
-	}
+		d2 = q + 2*d2;
+			q = (d2 * 0xd) >> 7;
+			d2 = d2 - 10*q;
+			*buf++ = d2 + '0';
 
-qualifier:
-	/* get the conversion qualifier */
-	spec->qualifier = -1;
-	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
-	    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
-		spec->qualifier = *fmt++;
-		if (unlikely(spec->qualifier == *fmt)) {
-			if (spec->qualifier == 'l') {
-				spec->qualifier = 'L';
-				++fmt;
-			} else if (spec->qualifier == 'h') {
-				spec->qualifier = 'H';
-				++fmt;
-			}
-		}
+			d3 = q + 4*d3;
+				q = (d3 * 0xcd) >> 11; /* - shorter code */
+				/* q = (d3 * 0x67) >> 10; - would also work */
+				d3 = d3 - 10*q;
+				*buf++ = d3 + '0';
+					*buf++ = q + '0';
+	return buf;
+}
+/* No inlining helps gcc to use registers better */
+static __noinline char* put_dec(char *buf, unsigned long long num)
+{
+	while (1) {
+		unsigned rem;
+		if (num < 100000)
+			return put_dec_trunc(buf, num);
+		rem = (unsigned) (num % 100000);
+		num = num / 100000;
+		buf = put_dec_full(buf, rem);
 	}
+}
 
-	/* default base */
-	spec->base = 10;
-	switch (*fmt) {
-	case 'c':
-		spec->type = FORMAT_TYPE_CHAR;
-		return ++fmt - start;
-
-	case 's':
-		spec->type = FORMAT_TYPE_STR;
-		return ++fmt - start;
-
-	case 'p':
-		spec->type = FORMAT_TYPE_PTR;
-		return fmt - start;
-		/* skip alnum */
-
-	case 'n':
-		spec->type = FORMAT_TYPE_NRCHARS;
-		return ++fmt - start;
-
-	case '%':
-		spec->type = FORMAT_TYPE_PERCENT_CHAR;
-		return ++fmt - start;
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SMALL	32		/* Must be 32 == 0x20 */
+#define SPECIAL	64		/* 0x */
 
-	/* integer number formats - set up the flags and "break" */
-	case 'o':
-		spec->base = 8;
-		break;
+enum format_type {
+	FORMAT_TYPE_NONE, /* Just a string part */
+	FORMAT_TYPE_WIDTH,
+	FORMAT_TYPE_PRECISION,
+	FORMAT_TYPE_CHAR,
+	FORMAT_TYPE_STR,
+	FORMAT_TYPE_PTR,
+	FORMAT_TYPE_PERCENT_CHAR,
+	FORMAT_TYPE_INVALID,
+	FORMAT_TYPE_LONG_LONG,
+	FORMAT_TYPE_ULONG,
+	FORMAT_TYPE_LONG,
+	FORMAT_TYPE_UBYTE,
+	FORMAT_TYPE_BYTE,
+	FORMAT_TYPE_USHORT,
+	FORMAT_TYPE_SHORT,
+	FORMAT_TYPE_UINT,
+	FORMAT_TYPE_INT,
+	FORMAT_TYPE_NRCHARS,
+	FORMAT_TYPE_SIZE_T,
+	FORMAT_TYPE_PTRDIFF
+};
 
-	case 'x':
-		spec->flags |= SMALL;
+struct printf_spec {
+	enum format_type	type;
+	int			flags;		/* flags to number() */
+	int			field_width;	/* width of output field */
+	int			base;
+	int			precision;	/* # of digits/chars */
+	int			qualifier;
+};
 
-	case 'X':
-		spec->base = 16;
-		break;
+static char *number(char *buf, char *end, unsigned long long num,
+			struct printf_spec spec)
+{
+	/* we are called with base 8, 10 or 16, only, thus don't need "G..."  */
+	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */
 
-	case 'd':
-	case 'i':
-		spec->flags |= SIGN;
-	case 'u':
-		break;
+	char tmp[66];
+	char sign;
+	char locase;
+	int need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);
+	int i;
 
-	default:
-		spec->type = FORMAT_TYPE_INVALID;
-		return fmt - start;
+	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
+	 * produces same digits or (maybe lowercased) letters */
+	locase = (spec.flags & SMALL);
+	if (spec.flags & LEFT)
+		spec.flags &= ~ZEROPAD;
+	sign = 0;
+	if (spec.flags & SIGN) {
+		if ((signed long long) num < 0) {
+			sign = '-';
+			num = - (signed long long) num;
+			spec.field_width--;
+		} else if (spec.flags & PLUS) {
+			sign = '+';
+			spec.field_width--;
+		} else if (spec.flags & SPACE) {
+			sign = ' ';
+			spec.field_width--;
+		}
 	}
-
-	if (spec->qualifier == 'L')
-		spec->type = FORMAT_TYPE_LONG_LONG;
-	else if (spec->qualifier == 'l') {
-		if (spec->flags & SIGN)
-			spec->type = FORMAT_TYPE_LONG;
-		else
-			spec->type = FORMAT_TYPE_ULONG;
-	} else if (spec->qualifier == 'Z' || spec->qualifier == 'z') {
-		spec->type = FORMAT_TYPE_SIZE_T;
-	} else if (spec->qualifier == 't') {
-		spec->type = FORMAT_TYPE_PTRDIFF;
-	} else if (spec->qualifier == 'H') {
-		if (spec->flags & SIGN)
-			spec->type = FORMAT_TYPE_BYTE;
-		else
-			spec->type = FORMAT_TYPE_UBYTE;
-	} else if (spec->qualifier == 'h') {
-		if (spec->flags & SIGN)
-			spec->type = FORMAT_TYPE_SHORT;
-		else
-			spec->type = FORMAT_TYPE_USHORT;
-	} else {
-		if (spec->flags & SIGN)
-			spec->type = FORMAT_TYPE_INT;
-		else
-			spec->type = FORMAT_TYPE_UINT;
+	if (need_pfx) {
+		spec.field_width--;
+		if (spec.base == 16)
+			spec.field_width--;
 	}
 
-	return ++fmt - start;
-}
-
-/**
- * vsnprintf - Format a string and place it in a buffer
- * @buf: The buffer to place the result into
- * @size: The size of the buffer, including the trailing null space
- * @fmt: The format string to use
- * @args: Arguments for the format string
- *
- * This function follows C99 vsnprintf, but has some extensions:
- * %pS output the name of a text symbol with offset
- * %ps output the name of a text symbol without offset
- * %pF output the name of a function pointer with its offset
- * %pf output the name of a function pointer without its offset
- * %pR output the address range in a struct resource
- * %n is ignored
- *
- * The return value is the number of characters which would
- * be generated for the given input, excluding the trailing
- * '\0', as per ISO C99. If you want to have the exact
- * number of characters written into @buf as return value
- * (not including the trailing '\0'), use vscnprintf(). If the
- * return is greater than or equal to @size, the resulting
- * string is truncated.
- *
- * Call this function if you are already dealing with a va_list.
- * You probably want snprintf() instead.
- */
-int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
-{
-	unsigned long long num;
-	char *str, *end, c;
-	int read;
-	struct printf_spec spec = {0};
-
-	/* Reject out-of-range values early.  Large positive sizes are
-	   used for unknown buffer sizes. */
-	if (WARN_ON_ONCE((int) size < 0))
-		return 0;
-
-	str = buf;
-	end = buf + size;
-
-	/* Make sure end is always >= buf */
-	if (end < buf) {
-		end = ((void *)-1);
-		size = end - buf;
+	/* generate full string in tmp[], in reverse order */
+	i = 0;
+	if (num == 0)
+		tmp[i++] = '0';
+	/* Generic code, for any base:
+	else do {
+		tmp[i++] = (digits[do_div(num,base)] | locase);
+	} while (num != 0);
+	*/
+	else if (spec.base != 10) { /* 8 or 16 */
+		int mask = spec.base - 1;
+		int shift = 3;
+		if (spec.base == 16) shift = 4;
+		do {
+			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
+			num >>= shift;
+		} while (num);
+	} else { /* base 10 */
+		i = put_dec(tmp, num) - tmp;
 	}
 
-	while (*fmt) {
-		const char *old_fmt = fmt;
-
-		read = format_decode(fmt, &spec);
-
-		fmt += read;
-
-		switch (spec.type) {
-		case FORMAT_TYPE_NONE: {
-			int copy = read;
-			if (str < end) {
-				if (copy > end - str)
-					copy = end - str;
-				memcpy(str, old_fmt, copy);
-			}
-			str += read;
-			break;
+	/* printing 100 using %2d gives "100", not "00" */
+	if (i > spec.precision)
+		spec.precision = i;
+	/* leading space padding */
+	spec.field_width -= spec.precision;
+	if (!(spec.flags & (ZEROPAD+LEFT))) {
+		while(--spec.field_width >= 0) {
+			if (buf < end)
+				*buf = ' ';
+			++buf;
 		}
+	}
+	/* sign */
+	if (sign) {
+		if (buf < end)
+			*buf = sign;
+		++buf;
+	}
+	/* "0x" / "0" prefix */
+	if (need_pfx) {
+		if (buf < end)
+			*buf = '0';
+		++buf;
+		if (spec.base == 16) {
+			if (buf < end)
+				*buf = ('X' | locase);
+			++buf;
+		}
+	}
+	/* zero or space padding */
+	if (!(spec.flags & LEFT)) {
+		char c = (spec.flags & ZEROPAD) ? '0' : ' ';
+		while (--spec.field_width >= 0) {
+			if (buf < end)
+				*buf = c;
+			++buf;
+		}
+	}
+	/* hmm even more zero padding? */
+	while (i <= --spec.precision) {
+		if (buf < end)
+			*buf = '0';
+		++buf;
+	}
+	/* actual digits of result */
+	while (--i >= 0) {
+		if (buf < end)
+			*buf = tmp[i];
+		++buf;
+	}
+	/* trailing space padding */
+	while (--spec.field_width >= 0) {
+		if (buf < end)
+			*buf = ' ';
+		++buf;
+	}
+	return buf;
+}
 
-		case FORMAT_TYPE_WIDTH:
-			spec.field_width = va_arg(args, int);
-			break;
-
-		case FORMAT_TYPE_PRECISION:
-			spec.precision = va_arg(args, int);
-			break;
+static char *string(char *buf, char *end, char *s, struct printf_spec spec)
+{
+	int len, i;
 
-		case FORMAT_TYPE_CHAR:
-			if (!(spec.flags & LEFT)) {
-				while (--spec.field_width > 0) {
-					if (str < end)
-						*str = ' ';
-					++str;
+	if ((unsigned long)s < PAGE_SIZE_4KB)
+		s = "<NULL>";
 
-				}
-			}
-			c = (unsigned char) va_arg(args, int);
-			if (str < end)
-				*str = c;
-			++str;
-			while (--spec.field_width > 0) {
-				if (str < end)
-					*str = ' ';
-				++str;
-			}
-			break;
+	len = strnlen(s, spec.precision);
 
-		case FORMAT_TYPE_STR:
-			str = string(str, end, va_arg(args, char *), spec);
-			break;
+	if (!(spec.flags & LEFT)) {
+		while (len < spec.field_width--) {
+			if (buf < end)
+				*buf = ' ';
+			++buf;
+		}
+	}
+	for (i = 0; i < len; ++i) {
+		if (buf < end)
+			*buf = *s;
+		++buf; ++s;
+	}
+	while (len < spec.field_width--) {
+		if (buf < end)
+			*buf = ' ';
+		++buf;
+	}
+	return buf;
+}
 
-		case FORMAT_TYPE_PTR:
-			str = pointer(fmt+1, str, end, va_arg(args, void *),
-				      spec);
-			while (isalnum(*fmt))
-				fmt++;
-			break;
+static char *symbol_string(char *buf, char *end, void *ptr,
+				struct printf_spec spec, char ext)
+{
+	unsigned long value = (unsigned long) ptr;
+#ifdef CONFIG_KALLSYMS
+	char sym[KSYM_SYMBOL_LEN];
+	if (ext != 'f' && ext != 's')
+		kallsyms_sprint_symbol(sym, value);
+	else
+		kallsyms_lookup(value, NULL, NULL, sym);
+	return string(buf, end, sym, spec);
+#else
+	spec.field_width = 2*sizeof(void *);
+	spec.flags |= SPECIAL | SMALL | ZEROPAD;
+	spec.base = 16;
+	return number(buf, end, value, spec);
+#endif
+}
 
-		case FORMAT_TYPE_PERCENT_CHAR:
-			if (str < end)
-				*str = '%';
-			++str;
-			break;
 
-		case FORMAT_TYPE_INVALID:
-			if (str < end)
-				*str = '%';
-			++str;
-			break;
+static char *mac_address_string(char *buf, char *end, uint8_t *addr,
+				struct printf_spec spec, const char *fmt)
+{
+	char mac_addr[sizeof("xx:xx:xx:xx:xx:xx")];
+	char *p = mac_addr;
+	int i;
 
-		case FORMAT_TYPE_NRCHARS: {
-			int qualifier = spec.qualifier;
+	for (i = 0; i < 6; i++) {
+		p = pack_hex_byte(p, addr[i]);
+		if (fmt[0] == 'M' && i != 5)
+			*p++ = ':';
+	}
+	*p = '\0';
 
-			if (qualifier == 'l') {
-				long *ip = va_arg(args, long *);
-				*ip = (str - buf);
-			} else if (qualifier == 'Z' ||
-					qualifier == 'z') {
-				size_t *ip = va_arg(args, size_t *);
-				*ip = (str - buf);
-			} else {
-				int *ip = va_arg(args, int *);
-				*ip = (str - buf);
-			}
-			break;
-		}
+	return string(buf, end, mac_addr, spec);
+}
 
-		default:
-			switch (spec.type) {
-			case FORMAT_TYPE_LONG_LONG:
-				num = va_arg(args, long long);
-				break;
-			case FORMAT_TYPE_ULONG:
-				num = va_arg(args, unsigned long);
-				break;
-			case FORMAT_TYPE_LONG:
-				num = va_arg(args, long);
-				break;
-			case FORMAT_TYPE_SIZE_T:
-				num = va_arg(args, size_t);
-				break;
-			case FORMAT_TYPE_PTRDIFF:
-				num = va_arg(args, ptrdiff_t);
-				break;
-			case FORMAT_TYPE_UBYTE:
-				num = (unsigned char) va_arg(args, int);
-				break;
-			case FORMAT_TYPE_BYTE:
-				num = (signed char) va_arg(args, int);
-				break;
-			case FORMAT_TYPE_USHORT:
-				num = (unsigned short) va_arg(args, int);
-				break;
-			case FORMAT_TYPE_SHORT:
-				num = (short) va_arg(args, int);
-				break;
-			case FORMAT_TYPE_INT:
-				num = (int) va_arg(args, int);
-				break;
-			default:
-				num = va_arg(args, unsigned int);
-			}
+static char *ip4_string(char *p, const uint8_t *addr, bool_t leading_zeros)
+{
+	int i;
 
-			str = number(str, end, num, spec);
+	for (i = 0; i < 4; i++) {
+		char temp[3];	/* hold each IP quad in reverse order */
+		int digits = put_dec_trunc(temp, addr[i]) - temp;
+		if (leading_zeros) {
+			if (digits < 3)
+				*p++ = '0';
+			if (digits < 2)
+				*p++ = '0';
 		}
+		/* reverse the digits in the quad */
+		while (digits--)
+			*p++ = temp[digits];
+		if (i < 3)
+			*p++ = '.';
 	}
 
-	if (size > 0) {
-		if (str < end)
-			*str = '\0';
-		else
-			end[-1] = '\0';
-	}
-
-	/* the trailing null byte doesn't count towards the total */
-	return str-buf;
-
+	*p = '\0';
+	return p;
 }
 
-/**
- * vscnprintf - Format a string and place it in a buffer
- * @buf: The buffer to place the result into
- * @size: The size of the buffer, including the trailing null space
- * @fmt: The format string to use
- * @args: Arguments for the format string
- *
- * The return value is the number of characters which have been written into
- * the @buf not including the trailing '\0'. If @size is <= 0 the function
- * returns 0.
- *
- * Call this function if you are already dealing with a va_list.
- * You probably want scnprintf() instead.
- *
- * See the vsnprintf() documentation for format string extensions over C99.
- */
-int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)
+static char *ip6_string(char *p, const char *addr, const char *fmt)
 {
 	int i;
+	for (i = 0; i < 8; i++) {
+		p = pack_hex_byte(p, *addr++);
+		p = pack_hex_byte(p, *addr++);
+		if (fmt[0] == 'I' && i != 7)
+			*p++ = ':';
+	}
 
-	i=vsnprintf(buf,size,fmt,args);
-	return (i >= size) ? (size - 1) : i;
+	*p = '\0';
+	return p;
 }
 
-/**
- * snprintf - Format a string and place it in a buffer
- * @buf: The buffer to place the result into
- * @size: The size of the buffer, including the trailing null space
- * @fmt: The format string to use
- * @...: Arguments for the format string
- *
- * The return value is the number of characters which would be
- * generated for the given input, excluding the trailing null,
- * as per ISO C99.  If the return is greater than or equal to
- * @size, the resulting string is truncated.
- *
- * See the vsnprintf() documentation for format string extensions over C99.
- */
-int snprintf(char * buf, size_t size, const char *fmt, ...)
+static char *ip6_addr_string(char *buf, char *end, const uint8_t *addr,
+			     struct printf_spec spec, const char *fmt)
 {
-	va_list args;
-	int i;
+	char ip6_addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")];
 
-	va_start(args, fmt);
-	i=vsnprintf(buf,size,fmt,args);
-	va_end(args);
-	return i;
-}
+	ip6_string(ip6_addr, addr, fmt);
 
-/**
- * scnprintf - Format a string and place it in a buffer
- * @buf: The buffer to place the result into
- * @size: The size of the buffer, including the trailing null space
- * @fmt: The format string to use
- * @...: Arguments for the format string
- *
- * The return value is the number of characters written into @buf not including
- * the trailing '\0'. If @size is <= 0 the function returns 0.
- */
+	return string(buf, end, ip6_addr, spec);
+}
 
-int scnprintf(char * buf, size_t size, const char *fmt, ...)
+static char *ip4_addr_string(char *buf, char *end, const uint8_t *addr,
+			     struct printf_spec spec, const char *fmt)
 {
-	va_list args;
-	int i;
+	char ip4_addr[sizeof("255.255.255.255")];
+
+	ip4_string(ip4_addr, addr, fmt[0] == 'i');
 
-	va_start(args, fmt);
-	i = vsnprintf(buf, size, fmt, args);
-	va_end(args);
-	return (i >= size) ? (size - 1) : i;
+	return string(buf, end, ip4_addr, spec);
 }
 
-/**
- * vsprintf - Format a string and place it in a buffer
- * @buf: The buffer to place the result into
- * @fmt: The format string to use
- * @args: Arguments for the format string
- *
- * The function returns the number of characters written
- * into @buf. Use vsnprintf() or vscnprintf() in order to avoid
- * buffer overflows.
+/*
+ * Show a '%p' thing.  A kernel extension is that the '%p' is followed
+ * by an extra set of alphanumeric characters that are extended format
+ * specifiers.
  *
- * Call this function if you are already dealing with a va_list.
- * You probably want sprintf() instead.
+ * Right now we handle:
  *
- * See the vsnprintf() documentation for format string extensions over C99.
+ * - 'F' For symbolic function descriptor pointers with offset
+ * - 'f' For simple symbolic function names without offset
+ * - 'S' For symbolic direct pointers with offset
+ * - 's' For symbolic direct pointers without offset
+ * - 'M' For a 6-byte MAC address, it prints the address in the
+ *       usual colon-separated hex notation
+ * - 'm' For a 6-byte MAC address, it prints the hex address without colons
+ * - 'I' [46] for IPv4/IPv6 addresses printed in the usual way
+ *       IPv4 uses dot-separated decimal without leading 0's (1.2.3.4)
+ *       IPv6 uses colon separated network-order 16 bit hex with leading 0's
+ * - 'i' [46] for 'raw' IPv4/IPv6 addresses
+ *       IPv6 omits the colons (01020304...0f)
+ *       IPv4 uses dot-separated decimal with leading 0's (010.123.045.006)
+ * - 'I6c' for IPv6 addresses printed as specified by
+ *       http://www.ietf.org/id/draft-kawamura-ipv6-text-representation-03.txt
+ * Note: The difference between 'S' and 'F' is that on ia64 and ppc64
+ * function pointers are really function descriptors, which contain a
+ * pointer to the real address.
  */
-int vsprintf(char *buf, const char *fmt, va_list args)
+static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
+			struct printf_spec spec)
 {
-	return vsnprintf(buf, INT_MAX, fmt, args);
+	if (!ptr)
+		return string(buf, end, "(null)", spec);
+
+	switch (*fmt) {
+	case 's':
+		/* Fallthrough */
+	case 'S':
+		return symbol_string(buf, end, ptr, spec, *fmt);
+	case 'M':			/* Colon separated: 00:01:02:03:04:05 */
+	case 'm':			/* Contiguous: 000102030405 */
+		return mac_address_string(buf, end, ptr, spec, fmt);
+	case 'I':			/* Formatted IP supported
+					 * 4:	1.2.3.4
+					 * 6:	0001:0203:...:0708
+					 * 6c:	1::708 or 1::1.2.3.4
+					 */
+	case 'i':			/* Contiguous:
+					 * 4:	001.002.003.004
+					 * 6:   000102...0f
+					 */
+		switch (fmt[1]) {
+		case '6':
+			return ip6_addr_string(buf, end, ptr, spec, fmt);
+		case '4':
+			return ip4_addr_string(buf, end, ptr, spec, fmt);
+		}
+		break;
+	}
+	spec.flags |= SMALL;
+	if (spec.field_width == -1) {
+		spec.field_width = 2*sizeof(void *);
+		spec.flags |= ZEROPAD;
+	}
+	spec.base = 16;
+
+	return number(buf, end, (unsigned long) ptr, spec);
 }
 
-/**
- * sprintf - Format a string and place it in a buffer
- * @buf: The buffer to place the result into
- * @fmt: The format string to use
- * @...: Arguments for the format string
+/*
+ * Helper function to decode printf style format.
+ * Each call decode a token from the format and return the
+ * number of characters read (or likely the delta where it wants
+ * to go on the next call).
+ * The decoded token is returned through the parameters
  *
- * The function returns the number of characters written
- * into @buf. Use snprintf() or scnprintf() in order to avoid
- * buffer overflows.
+ * 'h', 'l', or 'L' for integer fields
+ * 'z' support added 23/7/1999 S.H.
+ * 'z' changed to 'Z' --davidm 1/25/99
+ * 't' added for ptrdiff_t
  *
- * See the vsnprintf() documentation for format string extensions over C99.
+ * @fmt: the format string
+ * @type of the token returned
+ * @flags: various flags such as +, -, # tokens..
+ * @field_width: overwritten width
+ * @base: base of the number (octal, hex, ...)
+ * @precision: precision of a number
+ * @qualifier: qualifier of a number (long, size_t, ...)
  */
-int sprintf(char * buf, const char *fmt, ...)
+static int format_decode(const char *fmt, struct printf_spec *spec)
 {
-	va_list args;
-	int i;
+	const char *start = fmt;
 
-	va_start(args, fmt);
-	i=vsnprintf(buf, INT_MAX, fmt, args);
-	va_end(args);
-	return i;
-}
+	/* we finished early by reading the field width */
+	if (spec->type == FORMAT_TYPE_WIDTH) {
+		if (spec->field_width < 0) {
+			spec->field_width = -spec->field_width;
+			spec->flags |= LEFT;
+		}
+		spec->type = FORMAT_TYPE_NONE;
+		goto precision;
+	}
+
+	/* we finished early by reading the precision */
+	if (spec->type == FORMAT_TYPE_PRECISION) {
+		if (spec->precision < 0)
+			spec->precision = 0;
 
+		spec->type = FORMAT_TYPE_NONE;
+		goto qualifier;
+	}
 
-/**
- * vsscanf - Unformat a buffer into a list of arguments
- * @buf:	input buffer
- * @fmt:	format of buffer
- * @args:	arguments
- */
-int vsscanf(const char * buf, const char * fmt, va_list args)
-{
-	const char *str = buf;
-	char *next;
-	char digit;
-	int num = 0;
-	int qualifier;
-	int base;
-	int field_width;
-	int is_sign = 0;
+	/* By default */
+	spec->type = FORMAT_TYPE_NONE;
 
-	while(*fmt && *str) {
-		/* skip any white space in format */
-		/* white space in format matchs any amount of
-		 * white space, including none, in the input.
-		 */
-		if (isspace(*fmt)) {
-			while (isspace(*fmt))
-				++fmt;
-			while (isspace(*str))
-				++str;
-		}
+	for (; *fmt ; ++fmt) {
+		if (*fmt == '%')
+			break;
+	}
 
-		/* anything that is not a conversion must match exactly */
-		if (*fmt != '%' && *fmt) {
-			if (*fmt++ != *str++)
-				break;
-			continue;
+	/* Return the current non-format string */
+	if (fmt != start || !*fmt)
+		return fmt - start;
+
+	/* Process flags */
+	spec->flags = 0;
+
+	while (1) { /* this also skips first '%' */
+		bool_t found = true;
+
+		++fmt;
+
+		switch (*fmt) {
+		case '-': spec->flags |= LEFT;    break;
+		case '+': spec->flags |= PLUS;    break;
+		case ' ': spec->flags |= SPACE;   break;
+		case '#': spec->flags |= SPECIAL; break;
+		case '0': spec->flags |= ZEROPAD; break;
+		default:  found = false;
 		}
 
-		if (!*fmt)
+		if (!found)
 			break;
+	}
+
+	/* get field width */
+	spec->field_width = -1;
+
+	if (isdigit(*fmt))
+		spec->field_width = skip_atoi(&fmt);
+	else if (*fmt == '*') {
+		/* it's the next argument */
+		spec->type = FORMAT_TYPE_WIDTH;
+		return ++fmt - start;
+	}
+
+precision:
+	/* get the precision */
+	spec->precision = -1;
+	if (*fmt == '.') {
 		++fmt;
-		
-		/* skip this conversion.
-		 * advance both strings to next white space
-		 */
-		if (*fmt == '*') {
-			while (!isspace(*fmt) && *fmt != '%' && *fmt)
-				fmt++;
-			while (!isspace(*str) && *str)
-				str++;
-			continue;
+		if (isdigit(*fmt)) {
+			spec->precision = skip_atoi(&fmt);
+			if (spec->precision < 0)
+				spec->precision = 0;
+		} else if (*fmt == '*') {
+			/* it's the next argument */
+			spec->type = FORMAT_TYPE_PRECISION;
+			return ++fmt - start;
 		}
+	}
 
-		/* get field width */
-		field_width = -1;
-		if (isdigit(*fmt))
-			field_width = skip_atoi(&fmt);
-
-		/* get conversion qualifier */
-		qualifier = -1;
-		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
-		    *fmt == 'Z' || *fmt == 'z') {
-			qualifier = *fmt++;
-			if (unlikely(qualifier == *fmt)) {
-				if (qualifier == 'h') {
-					qualifier = 'H';
-					fmt++;
-				} else if (qualifier == 'l') {
-					qualifier = 'L';
-					fmt++;
-				}
+qualifier:
+	/* get the conversion qualifier */
+	spec->qualifier = -1;
+	if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
+	    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
+		spec->qualifier = *fmt++;
+		if (unlikely(spec->qualifier == *fmt)) {
+			if (spec->qualifier == 'l') {
+				spec->qualifier = 'L';
+				++fmt;
+			} else if (spec->qualifier == 'h') {
+				spec->qualifier = 'H';
+				++fmt;
 			}
 		}
-		base = 10;
-		is_sign = 0;
+	}
 
-		if (!*fmt || !*str)
-			break;
+	/* default base */
+	spec->base = 10;
+	switch (*fmt) {
+	case 'c':
+		spec->type = FORMAT_TYPE_CHAR;
+		return ++fmt - start;
 
-		switch(*fmt++) {
-		case 'c':
-		{
-			char *s = (char *) va_arg(args,char*);
-			if (field_width == -1)
-				field_width = 1;
-			do {
-				*s++ = *str++;
-			} while (--field_width > 0 && *str);
-			num++;
-		}
-		continue;
-		case 's':
-		{
-			char *s = (char *) va_arg(args, char *);
-			if(field_width == -1)
-				field_width = INT_MAX;
-			/* first, skip leading white space in buffer */
-			while (isspace(*str))
-				str++;
+	case 's':
+		spec->type = FORMAT_TYPE_STR;
+		return ++fmt - start;
 
-			/* now copy until next white space */
-			while (*str && !isspace(*str) && field_width--) {
-				*s++ = *str++;
-			}
-			*s = '\0';
-			num++;
-		}
-		continue;
-		case 'n':
-			/* return number of characters read so far */
-		{
-			int *i = (int *)va_arg(args,int*);
-			*i = str - buf;
-		}
-		continue;
-		case 'o':
-			base = 8;
-			break;
-		case 'x':
-		case 'X':
-			base = 16;
-			break;
-		case 'i':
-                        base = 0;
-		case 'd':
-			is_sign = 1;
-		case 'u':
-			break;
-		case '%':
-			/* looking for '%' in str */
-			if (*str++ != '%') 
-				return num;
-			continue;
-		default:
-			/* invalid format; stop here */
-			return num;
-		}
+	case 'p':
+		spec->type = FORMAT_TYPE_PTR;
+		return fmt - start;
+		/* skip alnum */
 
-		/* have some sort of integer conversion.
-		 * first, skip white space in buffer.
-		 */
-		while (isspace(*str))
-			str++;
+	case 'n':
+		spec->type = FORMAT_TYPE_NRCHARS;
+		return ++fmt - start;
 
-		digit = *str;
-		if (is_sign && digit == '-')
-			digit = *(str + 1);
+	case '%':
+		spec->type = FORMAT_TYPE_PERCENT_CHAR;
+		return ++fmt - start;
 
-		if (!digit
-                    || (base == 16 && !isxdigit(digit))
-                    || (base == 10 && !isdigit(digit))
-                    || (base == 8 && (!isdigit(digit) || digit > '7'))
-                    || (base == 0 && !isdigit(digit)))
-				break;
+	/* integer number formats - set up the flags and "break" */
+	case 'o':
+		spec->base = 8;
+		break;
 
-		switch(qualifier) {
-		case 'H':	/* that's 'hh' in format */
-			if (is_sign) {
-				signed char *s = (signed char *) va_arg(args,signed char *);
-				*s = (signed char) simple_strtol(str,&next,base);
-			} else {
-				unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
-				*s = (unsigned char) simple_strtoul(str, &next, base);
-			}
-			break;
-		case 'h':
-			if (is_sign) {
-				short *s = (short *) va_arg(args,short *);
-				*s = (short) simple_strtol(str,&next,base);
-			} else {
-				unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
-				*s = (unsigned short) simple_strtoul(str, &next, base);
-			}
-			break;
-		case 'l':
-			if (is_sign) {
-				long *l = (long *) va_arg(args,long *);
-				*l = simple_strtol(str,&next,base);
-			} else {
-				unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
-				*l = simple_strtoul(str,&next,base);
-			}
-			break;
-		case 'L':
-			if (is_sign) {
-				long long *l = (long long*) va_arg(args,long long *);
-				*l = simple_strtoll(str,&next,base);
-			} else {
-				unsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);
-				*l = simple_strtoull(str,&next,base);
-			}
-			break;
-		case 'Z':
-		case 'z':
-		{
-			size_t *s = (size_t*) va_arg(args,size_t*);
-			*s = (size_t) simple_strtoul(str,&next,base);
-		}
+	case 'x':
+		spec->flags |= SMALL;
+
+	case 'X':
+		spec->base = 16;
 		break;
-		default:
-			if (is_sign) {
-				int *i = (int *) va_arg(args, int*);
-				*i = (int) simple_strtol(str,&next,base);
-			} else {
-				unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
-				*i = (unsigned int) simple_strtoul(str,&next,base);
-			}
-			break;
-		}
-		num++;
 
-		if (!next)
-			break;
-		str = next;
+	case 'd':
+	case 'i':
+		spec->flags |= SIGN;
+	case 'u':
+		break;
+
+	default:
+		spec->type = FORMAT_TYPE_INVALID;
+		return fmt - start;
 	}
 
-	/*
-	 * Now we've come all the way through so either the input string or the
-	 * format ended. In the former case, there can be a %n at the current
-	 * position in the format that needs to be filled.
-	 */
-	if (*fmt == '%' && *(fmt + 1) == 'n') {
-		int *p = (int *)va_arg(args, int *);
-		*p = str - buf;
+	if (spec->qualifier == 'L')
+		spec->type = FORMAT_TYPE_LONG_LONG;
+	else if (spec->qualifier == 'l') {
+		if (spec->flags & SIGN)
+			spec->type = FORMAT_TYPE_LONG;
+		else
+			spec->type = FORMAT_TYPE_ULONG;
+	} else if (spec->qualifier == 'Z' || spec->qualifier == 'z') {
+		spec->type = FORMAT_TYPE_SIZE_T;
+	} else if (spec->qualifier == 't') {
+		spec->type = FORMAT_TYPE_PTRDIFF;
+	} else if (spec->qualifier == 'H') {
+		if (spec->flags & SIGN)
+			spec->type = FORMAT_TYPE_BYTE;
+		else
+			spec->type = FORMAT_TYPE_UBYTE;
+	} else if (spec->qualifier == 'h') {
+		if (spec->flags & SIGN)
+			spec->type = FORMAT_TYPE_SHORT;
+		else
+			spec->type = FORMAT_TYPE_USHORT;
+	} else {
+		if (spec->flags & SIGN)
+			spec->type = FORMAT_TYPE_INT;
+		else
+			spec->type = FORMAT_TYPE_UINT;
 	}
 
-	return num;
+	return ++fmt - start;
 }
 
+
+
 /**
- * sscanf - Unformat a buffer into a list of arguments
- * @buf:	input buffer
- * @fmt:	formatting of buffer
- * @...:	resulting arguments
+ * vscnprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * The return value is the number of characters which have been written into
+ * the @buf not including the trailing '\0'. If @size is <= 0 the function
+ * returns 0.
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want scnprintf() instead.
+ *
+ * See the vsnprintf() documentation for format string extensions over C99.
  */
-int sscanf(const char * buf, const char * fmt, ...)
+int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)
+{
+	int i;
+
+	i=vsnprintf(buf,size,fmt,args);
+	return (i >= size) ? (size - 1) : i;
+}
+
+/**
+ * scnprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @...: Arguments for the format string
+ *
+ * The return value is the number of characters written into @buf not including
+ * the trailing '\0'. If @size is <= 0 the function returns 0.
+ */
+
+int scnprintf(char * buf, size_t size, const char *fmt, ...)
 {
 	va_list args;
 	int i;
 
-	va_start(args,fmt);
-	i = vsscanf(buf,fmt,args);
+	va_start(args, fmt);
+	i = vsnprintf(buf, size, fmt, args);
 	va_end(args);
-	return i;
+	return (i >= size) ? (size - 1) : i;
 }
 
 /**
diff --git a/src/nautilus/shell.c b/src/nautilus/shell.c
index 293ef56..1c5efcc 100644
--- a/src/nautilus/shell.c
+++ b/src/nautilus/shell.c
@@ -35,6 +35,8 @@
 #include <nautilus/backtrace.h>
 #include <test/ipi.h>
 #include <test/threads.h>
+#include <test/newlib_fs.h>
+#include <dev/nvram.h>
 
 #ifdef NAUT_CONFIG_PALACIOS
 #include <nautilus/vmm.h>
@@ -58,6 +60,12 @@
 
 #define MAX_CMD 80
 
+// This is just for testing
+struct timeval {
+  unsigned long tv_sec;
+  unsigned long tv_usec;
+};
+
 struct burner_args {
     struct nk_virtual_console *vc;
     char     name[MAX_CMD];
@@ -773,6 +781,69 @@ static int handle_cmd(char *buf, int n)
     return 0;
   }
 
+  if (!strncasecmp(buf, "nvram_time", 10)) {
+    uint64_t time_since_epoch = nvram_time_since_epoch();
+    nk_vc_printf("Current time since epoch: %lu\n", time_since_epoch);
+
+    struct nvram_time cur_nvram_time;
+    int rc = nvram_gettime(&cur_nvram_time);
+    if(rc) {
+      nk_vc_printf("Failed to get RTC time\n");
+      return -1;
+    }
+
+    nk_vc_printf("Current unix time: %lu\n", cur_nvram_time.unix_time);
+
+#define R(x) nk_vc_printf( #x ": %u\n", cur_nvram_time.rtc_time.x)
+
+    R(year);
+    R(month);
+    R(day);
+    R(hour);
+    R(min);
+    R(sec);
+
+    return 0;
+  }
+
+
+  if (!strncasecmp(buf, "linux_time", 10)) {
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    nk_vc_printf("Current linux time: %ld\n", tv.tv_sec);
+    return 0;
+  }
+
+  if (!strncasecmp(buf, "lseek_test", 10)) {
+    lseek_test();
+    return 0;
+  }
+  
+  if (!strncasecmp(buf, "open_read_write", 15)) {
+    open_read_write();
+    return 0;
+  }
+
+  if (!strncasecmp(buf, "open_and_read", 13)) {
+    open_and_read();
+    return 0;
+  }
+
+  if (!strncasecmp(buf, "fp_test", 7)) {
+    check_function_pointers();
+    return 0;
+  }
+
+  if (!strncasecmp(buf, "open_test", 9)) {
+    open_simple_file();
+    return 0;
+  }
+  
+  if (!strncasecmp(buf, "hello", 5)) {
+    printf("Hello World!\n");
+    return 0;
+  }
+
   if (!strncasecmp(buf,"vcs",3)) {
     nk_switch_to_vc_list();
     return 0;
diff --git a/src/test/Makefile b/src/test/Makefile
index f9fafc0..c1f69e2 100644
--- a/src/test/Makefile
+++ b/src/test/Makefile
@@ -1,6 +1,6 @@
 CXXFLAGS += -DSHARED_LOWLEVEL -DCOMPILE_TIME_MIN_LEVEL=LEVEL_DEBUG  -D__LEGION__
 #-DDEBUG_LOWLEVEL -DDEBUG_HIGHLEVEL 
-obj-y = threads.o
+obj-y = threads.o newlib_fs.o
 
 obj-$(NAUT_CONFIG_X86_64_HOST) += ipi.o
 obj-$(NAUT_CONFIG_X86_64_HOST) += benchmark.o
